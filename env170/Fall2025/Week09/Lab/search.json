[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Watch This Space",
    "section": "",
    "text": "Introduction\nEnvironmental data is often spatial in nature. Think about air quality as an environmental health topic. The effects of air quality on health in a city are determined in part by the topography and wind patterns of the local area, locations where emissions occur, and civic planning of neighborhoods, all of which combine to determine which groups are exposed to more or less polluted air. The geographic context is fundamental for understanding the variability of environmental phenomenon and developing solutions to environmental problems.\nSpatial data typically comes in two main flavors: vector and raster. The vector data model is commonly used to represent discrete features: things that exist in some places but not others. Think about the locations of fountains, or roads, or the footprints of buildings: these are all discrete features of a city.\n\n\n\n\n\n\n\nsaylordotorg.github.io\n\n\nVector data usually presents spatial objects as one of three kinds of features:\n\npoints (a location only)\nlines (a series connected points; location AND length)\npolygons (a series of connected points that form a closed loop; location AND area)\n\nAdditionally, these features can have attributes which are information associated with the spatial object. For example, a polygon representing a building might have attributes such as address, owner’s name, date of construction, current value, etc. For our purposes, attributes are synonymous with variables.\nRasters, on the other and, are gridded cells that represent continuous data: think about the distribution of temperatures or levels of particulate matter across a city.\nIn this lab, we’re going to look at how to handle vector data in R. This allows us to integrate spatial data into our analyses without having to jump between software platforms, and share code and data in a way that is free and fully reproducible. Our main tools for doing this will be the sf and terra packages:\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(terra)\n\nThe sf package uses the Simple Features object format, where spatial information are stored as tables with a special “geometry” column. This makes them more flexible for use by other packages. You can read more about Simple Features here, and about the history of spatial data handling in R here.\nThe data for today’s lab is on Canvas in the Lab08Data.zip file.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_workingWithVector.html",
    "href": "01_workingWithVector.html",
    "title": "1  A First Look at Vector Data in R",
    "section": "",
    "text": "Reading vector data from shapefiles\nThe sf package offers a lot of different functionality for handling vector data, and interfaces with many different packages that extend our analytical and visualization capabilities. But before we get into these aspects, it’s probably useful to see how the Simple Features geometry works with some of the things we already know. In this section, we’ll work through importing data, making changes to it using some of the tidyverse functions, and visualizing it using ggplot2.\nBy and large, the ESRI shapefile is the standard for storing and sharing vector data. Shapefiles are actually collections of multiple files that store different aspects of the data (e.g., the .prj file contains projection information), but the main file in this structure is the .shp file. To read this kind of file, we’ll use the st_read function:\nsaCores&lt;-st_read(\"data/SACharCores.shp\")\n\nReading layer `SACharCores' from data source \n  `C:\\Users\\bdav_\\Dropbox\\Teaching\\ENV 170\\Fall 2025\\Fall 2025\\Week09\\Lab\\Lab09\\data\\SACharCores.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 27 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 18.11663 ymin: -34.66926 xmax: 32.3673 ymax: -22.85796\nGeodetic CRS:  WGS 84\nThese data are locations of sediment cores containing charcoal that have been collected from sites around South Africa used to reconstruct fire history. The message above gives us some summary information about the dataset:\nWe can access these attributes individually using built-in functions of the sf package, which usually begin with the prefix st_ (which stands for spatial type 1). For example, to get the coordinates of the bounding box edges, we can use st_bbox:\n#Get the bounding box values\nst_bbox(saCores)\n\n     xmin      ymin      xmax      ymax \n 18.11663 -34.66925  32.36730 -22.85796\nThis shows minimum and maximum x and y coordinates (here expressed in longitude and latitude) for the entire dataset. Likewise, if we wanted to access the coordinate reference system, we can use st_crs:\n#Get the bounding box values\nst_crs(saCores)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\nThis convoluted-looking set of data is a Well Known Text (WKT) formatting of coordinate reference information, developed by the Open Geospatial Consortium. It tells R what kind of space the coordinates exist in (e.g., planar vs spheroid).\nIf we just enter the spatial object’s name by itself, we get a summary of information about the dataset similar to the one above, but, like looking at a tibble, we also get a preview of the data itself:\nsaCores\n\nSimple feature collection with 27 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 18.11663 ymin: -34.66926 xmax: 32.3673 ymax: -22.85796\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   SiteNo                SiteName SiteCode                  geometry\n1     280             Craigrossie      CRA      POINT (28.46 -28.54)\n2     322            Rietvlei Dam       RD      POINT (28.27 -25.88)\n3     335               Lake Teza      TEZ  POINT (32.3007 -28.5117)\n4     378                    Elim      ELI      POINT (28.41 -28.48)\n5     455 Wonderkrater borehole 3      WON      POINT (28.75 -24.43)\n6     598             Lake Sibaya      SIB  POINT (32.3673 -27.2065)\n7     600                 Funduzi      FUN     POINT (30.3 -22.8583)\n8     771               Braamhoek      BRA POINT (29.58333 -28.2333)\n9     774         Moreletta River      MOR       POINT (28.3 -25.73)\n10   1476          Tswaing Crater       TC POINT (28.0832 -25.40865)\nThese are the variables associated with our data (sometimes called attributes in GIS lingo). At the end of the day this is just a table of data with an extra column, geometry, that stores the spatial information. In fact, if we wanted to remove the spatial information and just use the associated data, the package offers a handy st_drop_geometry function, which will just leave you with a tibble of the variables:\ncoreSites&lt;-st_drop_geometry(saCores)\ncoreSites\n\n   SiteNo                SiteName SiteCode\n1     280             Craigrossie      CRA\n2     322            Rietvlei Dam       RD\n3     335               Lake Teza      TEZ\n4     378                    Elim      ELI\n5     455 Wonderkrater borehole 3      WON\n6     598             Lake Sibaya      SIB\n7     600                 Funduzi      FUN\n8     771               Braamhoek      BRA\n9     774         Moreletta River      MOR\n10   1476          Tswaing Crater       TC\n11   1479  Scot's Farm Borehole 1      SFB\n12   1480              Tate Vondo       TV\n13   1481                 Mahwaqa      MHQ\n14    775     Cederberg Pakhuisch      PAK\n15   1458            Verlorenvlei      VER\n16   1459            Pearly Beach       PB\n17   1460        Rietvlei Wetland       RW\n18   1461         Eilandvlei lake      EIL\n19   1462                De Rif-1      DR*\n20   1463                De Rif-2     &lt;NA&gt;\n21   1472           Princess Vlei      PRI\n22   1473         Katbakkies Pass      KBP\n23   1474              Groenkloof      GKF\n24   1475               Platbos 1      PB1\n25   1477              Pella 1_4a     &lt;NA&gt;\n26   1478          Vankervelsvlei      VAN\n27   1482               Pella 1_1     PEL*",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>A First Look at Vector Data in R</span>"
    ]
  },
  {
    "objectID": "01_workingWithVector.html#footnotes",
    "href": "01_workingWithVector.html#footnotes",
    "title": "1  A First Look at Vector Data in R",
    "section": "",
    "text": "This is a coding convention carried over from functions used on spatial data stored in SQL databases.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>A First Look at Vector Data in R</span>"
    ]
  },
  {
    "objectID": "02_handingVectorData.html",
    "href": "02_handingVectorData.html",
    "title": "2  Vector Data Handling",
    "section": "",
    "text": "Making spatial data from scratch\nBecause sf objects are effectively tables, the process of making our own spatial data is pretty straightforward. Here, we’ll create three vectors. The first two will hold some x and y coordinates, while the last will be some made-up yes/no data. We’ll then combine these into a tibble called xydata:\n\nx&lt;-c(28,23,19)\ny&lt;-c(-26,-30,-33)\ndata&lt;-c(\"yes\",\"yes\",\"no\")\nxydata&lt;-tibble(x,y,data)\nxydata\n\n# A tibble: 3 × 3\n      x     y data \n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n1    28   -26 yes  \n2    23   -30 yes  \n3    19   -33 no   \n\n\nKeep in mind here that the negative numbers, which are on the y (latitude) axis, mean they are south of the equator. Most of the information we need to convert this into spatial data is here. We can use the st_as_sf function to go from a table to an sf object:\n\npointData&lt;-st_as_sf(xydata,coords=c(\"x\",\"y\"))\npointData\n\nSimple feature collection with 3 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 19 ymin: -33 xmax: 28 ymax: -26\nCRS:           NA\n# A tibble: 3 × 2\n  data  geometry\n  &lt;chr&gt;  &lt;POINT&gt;\n1 yes   (28 -26)\n2 yes   (23 -30)\n3 no    (19 -33)\n\n\nThe two arguments to st_as_sf here are the name of the table (xydata), and then the coords argument, which tells the function which columns the geometry data are stored in (in this case, the x and y columns).\nThe result looks a little different from what we’ve seen before, where the summary is presented as separate from the data table. The reason is that st_as_sf was principally designed to convert other spatial data formats that are built around Base R and the dataframe structure, making the package better at dealing with legacy code. However, this won’t make much difference in our ability to use the data:\n\nggplot() +\n  geom_sf(data=pointData)\n\n\n\n\n\n\n\n\nThe bigger issue here is that our data don’t yet have a coordinate reference system. The CRS tells R what kind of space our coordinates are in (e.g., planar vs. geodetic). To add one, we can use the st_crs function around our new dataset, and then assign a value:\n\nst_crs(pointData)&lt;-4326\n\nBy assigning a number to this, we are now giving the object a CRS. But why did we assign 4326? This number is an ESPG code, developed by the European Petroleum Survey Group for the registration of geodetic datums. This specific number refers to the WGS84 datum, which is the standard used for global positioning systems.\nCoincidentally, our South African data from the last section also use the same CRS:\n\nsaBorder&lt;-st_read(\"data/south_africa_border.shp\",quiet=TRUE)\nst_crs(saBorder)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nThis means that we can plot these two together without any distortion, like so:\n\nggplot() +\n  geom_sf(data=saBorder) +\n  geom_sf(data=pointData)\n\n\n\n\n\n\n\n\nKeep in mind that you can do this with just about any data table in R that has coordinates. For example, looking at our Sacramento data:\n\nlibrary(modeldata)\n\nWarning: package 'modeldata' was built under R version 4.5.1\n\n\n\nAttaching package: 'modeldata'\n\n\nThe following object is masked from 'package:datasets':\n\n    penguins\n\nsacSpat&lt;-st_as_sf(Sacramento,coords=c(\"longitude\",\"latitude\"))\nggplot()+\n  geom_sf(data=sacSpat, aes(color=type))\n\n\n\n\n\n\n\n\nOf course, for this map to work it would be helpful to see it on a map of Sacramento. We’ll look at ways to do this in a moment.\n\n\nVector data operations\nVector data can be used to answer questions related to spatial relationships between different things. We can access these using methods that operate on the data tables, using techniques we’ve learned in data wrangling, as well as the spatial data itself.\nFor example, let’s say that a study showed that the top threat to a species of moths on the Cape Cod islands was vehicle interactions. A commission on Martha’s Vineyard wants us to assess where moths are most threatened on the island. So we’re interested in looking at the relationship between the moth’s preferred habitat, and where that might overlap with traffic.\nFirst, we’ll load in data of the islands coastlines:\n\ncoasts&lt;-st_read(\"data/island_outline.shp\",quiet=TRUE)\ncoasts\n\nSimple feature collection with 18 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 255304.2 ymin: 777606.4 xmax: 329063.4 ymax: 804036.7\nProjected CRS: NAD83 / Massachusetts Mainland\nFirst 10 features:\n   OBJECTID Shape_Leng   Shape_Area                       geometry\n1         1  7014.7797 2352697.2299 POLYGON ((257734.8 779309.7...\n2         2 12001.3137 4559235.3924 POLYGON ((303023.4 785266.6...\n3         3   814.9956   27325.2581 POLYGON ((261860.9 786724.1...\n4         4   103.6876     443.1637 POLYGON ((300811 787461.1, ...\n5         5   220.8608    1700.1933 POLYGON ((299321.3 787528.6...\n6         6  1093.8214   42126.6728 POLYGON ((301238.1 787594.1...\n7         7  5405.8272 1173785.7943 POLYGON ((300537.6 788262.9...\n8         8   800.8689   26351.6747 POLYGON ((261301.3 788321.3...\n9         9   161.8800     918.3625 POLYGON ((300787.1 789076.4...\n10       10   313.2050    4361.2121 POLYGON ((301065.9 789324.7...\n\n\nThis dataset has 18 objects (in this case, polygons representing the coastlines of islands), and 3 fields/variables: OBJECTID (an ID number), Shape_Leng (the length of each polygon in m), and Shape_Area (the area of each polygon in m2) . Let’s plot it and have a look:\n\nggplot() +\n  geom_sf(data=coasts)\n\n\n\n\n\n\n\n\nMartha’s Vineyard is the larger island to the west. We don’t need to look at Nantucket or other smaller islands here, so we want to subset to just Martha’s Vineyard. Because the data are stored as a table, we can use our tidyverse tools here to help us. In this case, we can use slice_max from dplyr to get the largest island in dataset.\n\nmv&lt;-slice_max(coasts,Shape_Area)\nggplot() +\n  geom_sf(data=mv)\n\n\n\n\n\n\n\n\nRemembering back to our lab on data wrangling, the slice_max function selects the row that has the highest value in a given column. Since we gave it the Shape_Area column, the row with the highest value is the largest island: Martha’s Vineyard.\nNext, we’ll load in some data on the roads. But our road data covers both Martha’s Vineyard and Nantucket.\n\nroads&lt;-st_read(\"data/island_roads.shp\",quiet=TRUE)\nggplot() +\n  geom_sf(data=roads)\n\n\n\n\n\n\n\n\nIn this case, we want to subset to only those roads on Martha’s Vineyard. We can do this by using the st_intersection function with the mv object we created above:\n\nmvRoads&lt;-st_intersection(roads,mv)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot()+\n  geom_sf(data=mvRoads)\n\n\n\n\n\n\n\n\nThis is a form of overlay analysis. The st_intersection function takes two arguments at minimum: the first is the dataset of interest (roads), and the second is the dataset it is interacting with (mv). You could think of it like using a cookie-cutter, where the outline of the mv object is being used to cut out an Martha’s Vineyard-shaped section of the roads object. The result, as you can see, is any roads that intersects with our mv object.\nNow we need to know something about habitat distributions. We can use the island_landuse.shp file, but like our roads, we’ll need to subset it to Martha’s vineyard only.\n\nlanduse&lt;-st_read(\"data/island_landuse.shp\",quiet=TRUE)\nmvLanduse&lt;-st_intersection(landuse,mv)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot()+\n  geom_sf(data=mv) +\n  geom_sf(data=mvLanduse)\n\n\n\n\n\n\n\n\nThere’s a few different variables in this data (which comes from a state GIS database), but the one that’s most likely to help us figure out habitats and threats is the LU05_DESC, which is a description of landuse on a parcel of land as observed in 2005. The moth lives in Open as well as Brushland/ Successional habitats. We can subset to just these types with the filter function:\n\npreferredHabitats&lt;-filter(mvLanduse,LU05_DESC %in% c(\"Open Land\", \"Brushland/Successional\"))\nggplot()+\n  geom_sf(data=mv) +\n  geom_sf(data=preferredHabitats,fill=\"darkgreen\")\n\n\n\n\n\n\n\n\nOK, now we have everything we need. Let’s say the study found that most damage to moth populations occurred within 50 meters of a road. We can evaluate this relationship by using a buffer. A buffer creates a polygon at some even distance around a feature. This is useful when you want to see or measure how many instances of one thing fall within some distance of another.\nThe function we want to use for this is st_buffer, which will take as arguments the name of the object being buffered (in this case, the mvRoads) and a distance (in the default units here, 50m):\n\nroadBuffer&lt;-st_buffer(mvRoads,50)\nggplot()+\n  geom_sf(data=roadBuffer)\n\n\n\n\n\n\n\n\nAs you can see (though maybe not clearly) from this image, the lines where the roads are have now been surrounded by a polygon, giving us the area around the roads that are most dangerous for moths. Now we can look at the threat relationship between these preferred habitats and roads using the st_intersection function:\n\nroadThreat&lt;-st_intersection(preferredHabitats,roadBuffer)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot()+\n  geom_sf(data=mv) +\n  geom_sf(data=mvRoads) +\n  geom_sf(data=roadThreat,fill=\"red\",color=NA)\n\n\n\n\n\n\n\n\nThis map shows us where the months are most at risk, though perhaps it could do better at communicating these ideas. We can modify the look of figure to make sure the headline is clear:\n\nggplot()+\n  geom_sf(data=mv,fill=\"grey90\",color=NA) +\n  geom_sf(data=mvRoads,color=\"darkgrey\") +\n  geom_sf(data=roadThreat,fill=\"red\",color=NA) +\n  theme_void() +\n  labs(title=\"Where the moths of Martha's Vineyard are most threatened\", subtitle=\"Red indicates areas of high probability of road strike\")\n\n\n\n\n\n\n\n\n\n\nUsing joins to combine table and spatial data\nMore often than not, you may want to do some kind of analysis or visualization only to find you have one variable stored in one dataset, and another stored in another dataset. This can be a bit frustrating, but there are tools. The most helpful of these is the left_join function. This takes two datasets and uses a common shared variable to join them together. This can be particularly helpful when some\nThis can be particularly helpful when you have table data and want to map it. Let’s say we wanted to view our 2007 life expectancy data from the gapminder dataset as a map. First, we’ll subset bring in that data and subset it to just 2007 and just the country and lifeExp columns:\n\nlibrary(gapminder)\n\nWarning: package 'gapminder' was built under R version 4.5.1\n\ngm2007&lt;-gapminder %&gt;%\n  filter(year==2007) %&gt;%\n  select(country,lifeExp)\ngm2007\n\n# A tibble: 142 × 2\n   country     lifeExp\n   &lt;fct&gt;         &lt;dbl&gt;\n 1 Afghanistan    43.8\n 2 Albania        76.4\n 3 Algeria        72.3\n 4 Angola         42.7\n 5 Argentina      75.3\n 6 Australia      81.2\n 7 Austria        79.8\n 8 Bahrain        75.6\n 9 Bangladesh     64.1\n10 Belgium        79.4\n# ℹ 132 more rows\n\n\nNext, we’ll bring in a shapefile of world country boundaries, obtained from the very helpful website Natural Earth:\n\nworldCountries&lt;-st_read(\"data/world.shp\",quiet=TRUE)\nggplot() +\n  geom_sf(data=worldCountries)\n\n\n\n\n\n\n\n\nThis dataset has a lot of variables, most of them relating to database management. For now, we’ll cut this down to just the columns with the country name and its subregion.\n\nworldCountries&lt;-worldCountries %&gt;%\n  select(name,subregion)\nworldCountries\n\nSimple feature collection with 241 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.99893 xmax: 180 ymax: 83.59961\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs\nFirst 10 features:\n                   name       subregion                       geometry\n1                 Aruba       Caribbean MULTIPOLYGON (((-69.89912 1...\n2           Afghanistan   Southern Asia MULTIPOLYGON (((74.89131 37...\n3                Angola   Middle Africa MULTIPOLYGON (((14.19082 -5...\n4              Anguilla       Caribbean MULTIPOLYGON (((-63.00122 1...\n5               Albania Southern Europe MULTIPOLYGON (((20.06396 42...\n6                 Aland Northern Europe MULTIPOLYGON (((20.61133 60...\n7               Andorra Southern Europe MULTIPOLYGON (((1.706055 42...\n8  United Arab Emirates    Western Asia MULTIPOLYGON (((53.92783 24...\n9             Argentina   South America MULTIPOLYGON (((-64.54917 -...\n10              Armenia    Western Asia MULTIPOLYGON (((45.55234 40...\n\n\nOK, now we have our two datasets, with one column that contains the same value: the country name. In the gm2007 dataset, it’s in the country column, while in the worldCountries dataset, it’s stored as name.\nWe can use left_join from dplyr to put these two datasets together:\n\ngmJoin1&lt;-left_join(worldCountries,gm2007,by=c(\"name\"=\"country\"))\ngmJoin1\n\nSimple feature collection with 241 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.99893 xmax: 180 ymax: 83.59961\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs\nFirst 10 features:\n                   name       subregion lifeExp                       geometry\n1                 Aruba       Caribbean      NA MULTIPOLYGON (((-69.89912 1...\n2           Afghanistan   Southern Asia  43.828 MULTIPOLYGON (((74.89131 37...\n3                Angola   Middle Africa  42.731 MULTIPOLYGON (((14.19082 -5...\n4              Anguilla       Caribbean      NA MULTIPOLYGON (((-63.00122 1...\n5               Albania Southern Europe  76.423 MULTIPOLYGON (((20.06396 42...\n6                 Aland Northern Europe      NA MULTIPOLYGON (((20.61133 60...\n7               Andorra Southern Europe      NA MULTIPOLYGON (((1.706055 42...\n8  United Arab Emirates    Western Asia      NA MULTIPOLYGON (((53.92783 24...\n9             Argentina   South America  75.320 MULTIPOLYGON (((-64.54917 -...\n10              Armenia    Western Asia      NA MULTIPOLYGON (((45.55234 40...\n\n\nThe arguments here work as follows:\n\nWe give the function a dataset (here the worldCountries data). This is the data that we are joining to, so the output will look like worldCountries but with some additional variables from another dataset.\nThe gm2007 tibble is the second argument. The columns from this dataset will be attached to those from the worldCountries dataset.\nFinally, the by argument allows us to say which column from the first dataset (name) matches which column in the second dataset (country).\n\nOur new sf object now has the two columns from the original Natural Earth spatial data (name and subregion), as well as a new column for lifeExp that comes from the gm2007 data. Now we can plot our data and see what it looks like spatially.\n\nggplot() +\n  geom_sf(data=gmJoin1,aes(fill=lifeExp))\n\n\n\n\n\n\n\n\nThis let’s us see how the gapminder data looks on a familiar image: the world map. It also helps us more clearly see where data isn’t available (notably, central Asia and central Africa); this is less obvious when working with the table data.\nThis joining process will also work with two tables, or with two different sets of spatial data. As long as they can be linked by some common key value (here, the names of countries), you can combine them into a single dataset that can then be used for analysis and visualization.\n\n\n\n\n\n\nTry it yourself!\n\n\n\nThe left_join works by joining the first object (the leftmost one in the function call) to a second. What happens when you reverse the order of the input data? In other words can you join gm2007 tibble to the worldCountries sf object? Can you create boxplots of life expectancy based on subregion?\n\n\nThere are many additional ways you might want to manipulate spatial data in R. Unfortunately, going into them in detail is outside the scope of this course. For now, if you’re interested in learning more, the book Geocomputation with R gives an excellent survey of spatial data manipulation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector Data Handling</span>"
    ]
  },
  {
    "objectID": "03_plottingVectorData.html",
    "href": "03_plottingVectorData.html",
    "title": "3  Additional plotting considerations",
    "section": "",
    "text": "Modifying extents and adding map elements\nLet’s rebuild our South Africa map of cores and biomes:\nggplot() + \n  geom_sf(data= saBiomes,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=saCores)\nLet’s say that we were just interested in the area around Western Cape province (in the southwest part of South Africa). In an earlier session, we looked at how we can zoom in on a plot using coord_cartesian to set new limits to the extent being plotted. A similar function, coords_sf, let’s us do this with our spatial data:\nggplot() + \n  geom_sf(data= saBiomes,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=saCores) +\n  coord_sf(xlim = c(17, 23), ylim = c(-35, -30), expand = FALSE)\nThis looks OK, but now there’s a whole bunch of colors in the legend that don’t correspond to anything on the map. The reason is that even though we’ve zoomed in, we haven’t actually subset the data, so the original mapping to the legend still stands. We can use st_crop to crop the data to our new bounding box.\nbiomesCrop&lt;-st_crop(saBiomes, xmin=17, xmax=23, ymin=-35, ymax=-30)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\ncoresCrop&lt;-st_crop(saCores, xmin=17, xmax=23, ymin=-35, ymax=-30)\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop)\nThis takes the name of the sf object as the first argument, and then a series of values indicating the minimum and maximum extents along the x and y axes. The color scheme has changed now since we’re not using so many of them.\nLet’s add a couple more things to our plot: a north arrow and a scale bar. The easiest way to do this is to call up the ggspatial package:\nlibrary(ggspatial)\n\nWarning: package 'ggspatial' was built under R version 4.5.1\n\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop) +\n   annotation_north_arrow()\nHere we used the annotation_north_arrow() function to get our arrow, but eek! It’s gigantic! We can play around with some settings, like height and width, to get it into a more reasonable shape:\nlibrary(ggspatial)\n\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop) +\n   annotation_north_arrow(height = unit(0.75, \"cm\"), width = unit(0.5, \"cm\"))\nThis looks better. Now for a scale bar using annotation_scale:\nggplot() + \n  geom_sf(data= biomesCrop,aes(fill=BIOME),color=NA) +\n  theme_classic() +\n  labs(fill=\"Biome\") +\n  scale_fill_brewer(palette=\"Set3\") +\n  geom_sf(data=coresCrop) +\n   annotation_north_arrow(height = unit(0.75, \"cm\"), width = unit(0.5, \"cm\")) +\n  annotation_scale(location = \"br\")\nThe location argument that is used here (“br”) indicates that we want to put it in the bottom right corner. We could use “tr” for top right, or “bl” for bottom left. It’s entirely up to you!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Additional plotting considerations</span>"
    ]
  },
  {
    "objectID": "03_plottingVectorData.html#modifying-extents-and-adding-map-elements",
    "href": "03_plottingVectorData.html#modifying-extents-and-adding-map-elements",
    "title": "3  Additional plotting considerations",
    "section": "",
    "text": "Try it yourself!\n\n\n\nThere are lots of different options for changing the look and feel of these map elements, such as the size, location, and style. Have a look at the help documentation for these two functions to get a better sense.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Additional plotting considerations</span>"
    ]
  }
]
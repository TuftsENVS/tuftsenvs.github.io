[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cleaning, Tidying, and Wrangling Data",
    "section": "",
    "text": "Introduction\nDatasets are often assembled in ways that facilitate data collection, with limited consideration given to how they are analyzed. This is especially true when data is being re-used from published sources and the new use is outside of the scope of what the data authors intended. There is a saying, largely anecdotal but probably accurate, that data scientists spend 80% of their time cleaning and organizing data.\nThe combined processes of data cleaning, organizing, and transforming are often subsumed under the term data wrangling. The dictionary definitions of the term “wrangle” are:\n\nhave a long and complicated dispute\nround up, herd, or take charge of (livestock)\n\nBoth of these definitions are strangely appropriate. Working with data can often feel like a discussion, sometimes a heated one, in which you are trying to convince the data to yield to a particular form that allows easier integration into a data workflow. It can also sometimes feel as though you are tending to a herd of animals (cats come to mind), trying to create order from what otherwise seems like a chaotic dataset.\nWe have already done some of this in previous lectures. For example, we have seen how we can add transformed columns to a table using the $ and &lt;- operators; we have seen how we can subset cases using square brackets [] and the subset function, and we have used exploratory data analysis to identify suspect and outlier values. However, because wrangling makes up so much of what we do as data scientists, specialized tools have been developed to deal with them, and these available to us through the tidyverse family of packages. In this lab, you will learn to:\n\nsubset, reorder, and transform data using tools from the dplyr package\ncreate tidy datasets using the pivot functions from the tidyr package\nuse helper functions from packages like tidyselect and stringr\n\nIf you haven’t done so already, I recommend creating a file system, opening a new Quarto document. I’d suggest giving each of the pages in this lab its own heading (see the table of contents). We’ll be using the tree inventory data, which is posted on Canvas. And don’t forget to load the tidyverse package!\n\nlibrary(tidyverse)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_subsetting.html",
    "href": "01_subsetting.html",
    "title": "1  Getting started with wrangling",
    "section": "",
    "text": "Data wrangling includes operations for manipulating data. This may be for restructuring data into forms are usable as arguments in analytical functions; transforming values to facilitate visualizations; creating polished data for use by the public; or even just to clarify the look and structure of the data for your own benefit. The kinds of operations that might be undertaken depend on what the data looks like in its raw (received) state. However, there are some common operations that have been built into the packages that make up the tidyverse, and we’ll explore some here.\n\nIntroducing dplyr\nThe dplyr (dee-ply-er) package contains a set of tools designed principally for activities associated with data wrangling. These tools follow a sort of grammar, whereby the name of the function relates directly to what it does to the data (e.g., filter “filters”, select “selects”, etc.). The function name is followed by arguments that follow a general structure:\n\nThe first argument in a dyplr function is always a table (e.g., tibble, data frame)\nFurther arguments describe operations on columns in that table (with column names that are expressed without $ or quotes)\nThe result is always a table\n\nThere’s a few reasons why you might want to use these functions. The first is code clarity: most of the operations we’ve done so far use operators specific to Base R (e.g., $), whereas these have more intuitive names and follow the same patterns across their usage (helping with code readability). Another is that the dplyr tools have been designed specifically with data wrangling in mind, and so contain a number of options and integration that allow for smoother transitions between data states and, ultimately, fewer lines of code.\nTo illustrate how these work, we’ll start by going through some of the functions used to create subsets of data.\n\n\nSubsetting\nOftentimes, the data we receive may have more variables, observations, or values than we would like. Let’s look at the tree inventory dataset:\n\ntreeData&lt;-read_csv(\"data/TS3_Raw_tree_data.csv\")\ntreeData\n\n# A tibble: 14,487 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 14,477 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nHere, we have over 14,000 observations across 41 different variables. There are both practical and analytic reasons you might want to subset this dataset. For example, if you have to regularly refer to a few columns, it may get frustrating to have to keep scrolling across them or calling for a list of column names. Or maybe you are being hired to work on a question about trees in a specific city, and the values from the others are superfluous to your needs. Let’s look at a few functions that can help us address these by subsetting the data into smaller packages.\n\n\nFilter\nThe filter function subsets the data according to a given set of criteria. So, carrying on from our last example, let’s say you were doing an analysis of street trees in Modesto, California:\n\nfilter(treeData,City==\"Modesto, CA\")\n\n# A tibble: 634 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 624 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nQuite clear, yes? The first argument is a table (the treeData tibble), and the second is criteria referring to the City column. The result is another table, but this one only containing observations from Modesto.\nBy itself, this works precisely the same as selecting using the $ operator and square brackets:\n\ntreeData[treeData$City==\"Modesto, CA\",]\n\n# A tibble: 634 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 624 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nSo why bother with filter? Why not just stick with square brackets? This function enables us to make more complex subsets with less code, and the code that it produces is ultimately more readable. We can get a feel for this by asking for additional information. For example, let’s say we wanted to look at data from Modesto and Sacramento. With filter, it would look something like this:\n\nfilter(treeData,City %in% c(\"Modesto, CA\",\"Sacramento, CA\"))\n\n# A tibble: 1,635 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 1,625 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nWe’ve learned how to do this similarly in Base R:\n\ntreeData[treeData$City %in% c(\"Modesto, CA\", \"Sacramento, CA\"),]\n\n# A tibble: 1,635 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 1,625 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nThis doesn’t seem so different; however, when you’re working with square brackets, you need to remember to include the comma at the end of the statement to indicate that you are subsetting row-wise. Woe be it to those who forget that precious comma.\nOK, let’s try something a little more complicated: what if we wanted to filter to all the maple trees in Modesto? Here, we can combine our dplyr code with a helper function from elsewhere in the tidyverse: the str_detect function from the stringr package. This will detect whether a text string we provide matches anywhere in another text string.\n\nmodestoMaples&lt;-filter(treeData,City==\"Modesto, CA\" & str_detect(CommonName,\"maple\"))\nmodestoMaples\n\n# A tibble: 29 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2      43 InlVal Modes… Motow…   2961 -1    -1            ACSA1  Acer sacchari…\n 3      96 InlVal Modes… Motow…   9733 -1    -1            ACSA1  Acer sacchari…\n 4     306 InlVal Modes… Motow…  31877 -1    -1            ACSA1  Acer sacchari…\n 5     309 InlVal Modes… Motow…  32147 -1    -1            ACSA1  Acer sacchari…\n 6     310 InlVal Modes… Motow…  32193 -1    -1            ACSA1  Acer sacchari…\n 7     314 InlVal Modes… Motow…  32333 -1    -1            ACSA1  Acer sacchari…\n 8     318 InlVal Modes… Motow…  33269 -1    -1            ACSA1  Acer sacchari…\n 9     324 InlVal Modes… Motow…  34001 -1    -1            ACSA1  Acer sacchari…\n10     329 InlVal Modes… Motow…  35120 -1    -1            ACSA1  Acer sacchari…\n# ℹ 19 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nDoing this in Base R involves using the grepl function, which is a function that uses a computational technique called regular expressions to match patterns in character objects:\n\nmodestoMaples&lt;-treeData[treeData$City==\"Modesto, CA\" & grepl(\"maple\",treeData$CommonName),]\nmodestoMaples\n\n# A tibble: 29 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2      43 InlVal Modes… Motow…   2961 -1    -1            ACSA1  Acer sacchari…\n 3      96 InlVal Modes… Motow…   9733 -1    -1            ACSA1  Acer sacchari…\n 4     306 InlVal Modes… Motow…  31877 -1    -1            ACSA1  Acer sacchari…\n 5     309 InlVal Modes… Motow…  32147 -1    -1            ACSA1  Acer sacchari…\n 6     310 InlVal Modes… Motow…  32193 -1    -1            ACSA1  Acer sacchari…\n 7     314 InlVal Modes… Motow…  32333 -1    -1            ACSA1  Acer sacchari…\n 8     318 InlVal Modes… Motow…  33269 -1    -1            ACSA1  Acer sacchari…\n 9     324 InlVal Modes… Motow…  34001 -1    -1            ACSA1  Acer sacchari…\n10     329 InlVal Modes… Motow…  35120 -1    -1            ACSA1  Acer sacchari…\n# ℹ 19 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nCompare those last two examples in terms of their readability. The code in the tidyverse version more or less follows a pattern consistent with what you are asking it to do (‘filter the data to instances where the city is Modesto and the common name includes “maple”’). The Base R version is a little less straightforward. It uses redundant references to the name of the dataset (treeData), multiple types of brackets, commas separating both arguments and table dimensions, and sometimes reverses the pattern of inputs (data, argument vs argument, data).\n\n\n\n\n\n\nTry it yourself!\n\n\n\nTry writing the following Base R sub-setting routines using the filter function:\ntreeData[treeData$CrnBase&gt;5,]\ntreeData[treeData$`Park/Street`!=\"Park\",]\ntreeData[treeData$ScientificName==\"Pinus radiata\" | treeData$ScientificName==\"Sequoia sempervirens\",]\n\n\nIt should be made clear, though, that anything you want to do in tidyverse can be done in Base R, and if you ultimately decide you are more comfortable with the Base R syntax then there is no harm using it. However, as you work on more complex analyses, and work with messier data, the methods used in Base R will be more and more dependent on coding conventions that were developed without a data science workflow in mind. This creates opportunities for errors to creep in, such as misplaced commas and brackets, incorrect orders of arguments, etc. The tidyverse grammar offers more straightforward path through the data science. We’ll illustrate these concepts with a few additional functions below.\n\n\nSelect\nThe select function allows us to select particular columns to include in a smaller dataset. For example, let’s say that we are interested only in some of the measurements on the trees and less concerned with their location. We can use select by first giving the data table, followed by the names of the columns:\n\ntreeMetrics&lt;-select(treeData,DbaseID,ScientificName,`DBH (cm)`,`TreeHt (m)`,`Leaf (m2)`)\ntreeMetrics\n\n# A tibble: 14,487 × 5\n   DbaseID ScientificName                    `DBH (cm)` `TreeHt (m)` `Leaf (m2)`\n     &lt;dbl&gt; &lt;chr&gt;                                  &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n 1       1 Acer saccharinum                         2.5          2           2.5\n 2       2 Betula pendula                           2.5          1.5         1.9\n 3       3 Celtis sinensis                          2.5          1.8         2.2\n 4       4 Cinnamomum camphora                      2.5          2           2  \n 5       5 Fraxinus angustifolia 'Raywood'          2.5          2           2.2\n 6       6 Fraxinus excelsior 'Hessei'              2.5          2           2.2\n 7       7 Fraxinus holotricha                      2.5          2           2.2\n 8       8 Fraxinus pennsylvanica 'Marshall'        2.5          2           2.2\n 9       9 Fraxinus velutina 'Modesto'              2.5          2           2.1\n10      10 Ginkgo biloba                            2.5          1.6         1.3\n# ℹ 14,477 more rows\n\n\nNote that here we are using backticks (``) to indicate non-conforming column names (i.e., column names with whitespace or other meaningful symbols in R). Again, we could do this with square brackets by giving it the column indices:\n\ntreeMetrics&lt;-treeData[,c(\"DbaseID\",\"ScientificName\",\"DBH (cm)\",\"TreeHt (m)\",\"Leaf (m2)\")]\ntreeMetrics\n\n# A tibble: 14,487 × 5\n   DbaseID ScientificName                    `DBH (cm)` `TreeHt (m)` `Leaf (m2)`\n     &lt;dbl&gt; &lt;chr&gt;                                  &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n 1       1 Acer saccharinum                         2.5          2           2.5\n 2       2 Betula pendula                           2.5          1.5         1.9\n 3       3 Celtis sinensis                          2.5          1.8         2.2\n 4       4 Cinnamomum camphora                      2.5          2           2  \n 5       5 Fraxinus angustifolia 'Raywood'          2.5          2           2.2\n 6       6 Fraxinus excelsior 'Hessei'              2.5          2           2.2\n 7       7 Fraxinus holotricha                      2.5          2           2.2\n 8       8 Fraxinus pennsylvanica 'Marshall'        2.5          2           2.2\n 9       9 Fraxinus velutina 'Modesto'              2.5          2           2.1\n10      10 Ginkgo biloba                            2.5          1.6         1.3\n# ℹ 14,477 more rows\n\n\nSince this kind of subsetting requires us to give column names as character values, we don’t need the backticks. But here our argument is a vector of column names inside of square brackets.\nThe power of select lies in its ability to take additional arguments and interface with helper functions. For example, we can use the starts_with function to request only the columns containing DBH values:\n\nallDBH&lt;-select(treeData,DbaseID,starts_with(\"dbh\"))\nallDBH\n\n# A tibble: 14,487 × 10\n   DbaseID `DBH (cm)`  dbh1  dbh2  dbh3  dbh4  dbh5  dbh6  dbh7  dbh8\n     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1       1        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 2       2        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 3       3        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 4       4        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 5       5        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 6       6        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 7       7        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 8       8        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n 9       9        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n10      10        2.5   2.5    -1    -1    -1    -1    -1    -1    -1\n# ℹ 14,477 more rows\n\n\nThe starts_with function actually comes from the tidyselect package, which is also loaded as part of tidyverse. We can also add additional arguments to this call to refine it. For example, we can use ignore.case to not include the first column with DBH (the overall DBH measurement) where it is in all capitals and only keep the individual stem measurements that use lower case:\n\nallDBH&lt;-select(treeData,DbaseID,starts_with(\"dbh\",ignore.case = FALSE))\nallDBH\n\n# A tibble: 14,487 × 9\n   DbaseID  dbh1  dbh2  dbh3  dbh4  dbh5  dbh6  dbh7  dbh8\n     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1       1   2.5    -1    -1    -1    -1    -1    -1    -1\n 2       2   2.5    -1    -1    -1    -1    -1    -1    -1\n 3       3   2.5    -1    -1    -1    -1    -1    -1    -1\n 4       4   2.5    -1    -1    -1    -1    -1    -1    -1\n 5       5   2.5    -1    -1    -1    -1    -1    -1    -1\n 6       6   2.5    -1    -1    -1    -1    -1    -1    -1\n 7       7   2.5    -1    -1    -1    -1    -1    -1    -1\n 8       8   2.5    -1    -1    -1    -1    -1    -1    -1\n 9       9   2.5    -1    -1    -1    -1    -1    -1    -1\n10      10   2.5    -1    -1    -1    -1    -1    -1    -1\n# ℹ 14,477 more rows\n\n\nThere are several of these helper functions that work in this case:\n\n#columns ending with the word \"Name\"\nallNames&lt;-select(treeData,ends_with(\"Name\",ignore.case = TRUE))\nallNames\n\n# A tibble: 14,487 × 2\n   ScientificName                    CommonName          \n   &lt;chr&gt;                             &lt;chr&gt;               \n 1 Acer saccharinum                  Silver maple        \n 2 Betula pendula                    European white birch\n 3 Celtis sinensis                   Chinese hackberry   \n 4 Cinnamomum camphora               Camphor tree        \n 5 Fraxinus angustifolia 'Raywood'   Raywood ash         \n 6 Fraxinus excelsior 'Hessei'       Hesse ash           \n 7 Fraxinus holotricha               Moraine ash         \n 8 Fraxinus pennsylvanica 'Marshall' Marshall ash        \n 9 Fraxinus velutina 'Modesto'       Modesto ash         \n10 Ginkgo biloba                     Ginkgo              \n# ℹ 14,477 more rows\n\n#columns containing the word \"Street\"\nallStreet&lt;-select(treeData,DbaseID,contains(\"Street\",ignore.case = FALSE))\nallStreet\n\n# A tibble: 14,487 × 5\n   DbaseID `Park/Street` OnStreet FromStreet ToStreet\n     &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;   \n 1       1 Nursery       -1       -1         -1      \n 2       2 Nursery       -1       -1         -1      \n 3       3 Nursery       -1       -1         -1      \n 4       4 Nursery       -1       -1         -1      \n 5       5 Nursery       -1       -1         -1      \n 6       6 Nursery       -1       -1         -1      \n 7       7 Nursery       -1       -1         -1      \n 8       8 Nursery       -1       -1         -1      \n 9       9 Nursery       -1       -1         -1      \n10      10 Nursery       -1       -1         -1      \n# ℹ 14,477 more rows\n\n\nFinally, when selecting columns, you also have an opportunity to rename them as you’d prefer, assigning them by entering the new name in quotes (e.g., “LeafArea”) and the column name (e.g.,`Leaf (m2)`)\n\ntreeMetrics&lt;-select(treeData,\"ID\"=DbaseID,\"Name\"=ScientificName,\"DBH\"=`DBH (cm)`,\"Height\"=`TreeHt (m)`,\"LeafArea\"=`Leaf (m2)`)\ntreeMetrics\n\n# A tibble: 14,487 × 5\n      ID Name                                DBH Height LeafArea\n   &lt;dbl&gt; &lt;chr&gt;                             &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n 1     1 Acer saccharinum                    2.5    2        2.5\n 2     2 Betula pendula                      2.5    1.5      1.9\n 3     3 Celtis sinensis                     2.5    1.8      2.2\n 4     4 Cinnamomum camphora                 2.5    2        2  \n 5     5 Fraxinus angustifolia 'Raywood'     2.5    2        2.2\n 6     6 Fraxinus excelsior 'Hessei'         2.5    2        2.2\n 7     7 Fraxinus holotricha                 2.5    2        2.2\n 8     8 Fraxinus pennsylvanica 'Marshall'   2.5    2        2.2\n 9     9 Fraxinus velutina 'Modesto'         2.5    2        2.1\n10    10 Ginkgo biloba                       2.5    1.6      1.3\n# ℹ 14,477 more rows\n\n\nIf you only want to rename some columns without selecting a subset of them, you can use the rename function:\n\ntreeMetrics&lt;-rename(treeMetrics,\"DBH_cm\"=DBH,\"Height_m\"=Height,\"LeafArea_m2\"=LeafArea)\ntreeMetrics\n\n# A tibble: 14,487 × 5\n      ID Name                              DBH_cm Height_m LeafArea_m2\n   &lt;dbl&gt; &lt;chr&gt;                              &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n 1     1 Acer saccharinum                     2.5      2           2.5\n 2     2 Betula pendula                       2.5      1.5         1.9\n 3     3 Celtis sinensis                      2.5      1.8         2.2\n 4     4 Cinnamomum camphora                  2.5      2           2  \n 5     5 Fraxinus angustifolia 'Raywood'      2.5      2           2.2\n 6     6 Fraxinus excelsior 'Hessei'          2.5      2           2.2\n 7     7 Fraxinus holotricha                  2.5      2           2.2\n 8     8 Fraxinus pennsylvanica 'Marshall'    2.5      2           2.2\n 9     9 Fraxinus velutina 'Modesto'          2.5      2           2.1\n10    10 Ginkgo biloba                        2.5      1.6         1.3\n# ℹ 14,477 more rows\n\n\n\n\nSlice\nThe slice function is used to select a subset of rows using their indices (i.e., row numbers). For example, to get the first 100 rows, you could use:\n\nslice(treeData,1:100)\n\n# A tibble: 100 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 90 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nThe slice function is actually one of a few different slice-based functions that serve different purposes. For example, the slice_sample allows us to take a random subset of rows from our data:\n\nslice_sample(treeData,n=100)\n\n# A tibble: 100 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1    3152 SWDsrt Glend… GDLMa…    723 -1    Park          WARO   Washingtonia …\n 2    9503 InterW Albuq… ABQMa…  17578 West… Park          FRPE   Fraxinus penn…\n 3    8676 TpIntW Boise… BOIMa…  46566 3A    Street        GLTR   Gleditsia tri…\n 4    7174 NoEast Queen… JFKMa… 252394 411   Street        ACSA1  Acer sacchari…\n 5    4439 NMtnPr Fort … FNLMa…    823 -1    Street        ACPL   Acer platanoi…\n 6    9298 InterW Albuq… ABQMa…  12380 High… Park          ULPU   Ulmus pumila  \n 7   13518 PacfNW Longv… Longv…   6491 -1    Street        PRCE   Prunus cerasi…\n 8    5895 LoMidW India… INDMa…    443 B04   -1            GLTR   Gleditsia tri…\n 9    2664 NoCalC Berke… JBKMa…  29771 1     Park          SESE   Sequoia sempe…\n10    7936 TpIntW Boise… BOIMa…   1275 1A    Street        ULPU   Ulmus pumila  \n# ℹ 90 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nOr we can get the top fifty trees by height using slice_max:\n\nslice_max(treeData,`TreeHt (m)`,n=50)\n\n# A tibble: 55 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1    2665 NoCalC Berke… JBKMa…  29784 1     Park          SESE   Sequoia sempe…\n 2   13635 PacfNW Longv… Longv…   8919 -1    Park          POTR2  Populus balsa…\n 3    2617 NoCalC Berke… JBKMa…  28535 2     Park          EUGL   Eucalyptus gl…\n 4    2636 NoCalC Berke… JBKMa…  28918 2     Park          EUGL   Eucalyptus gl…\n 5   11741 Piedmt Charl… CLTMa…  43077 G6    Street        QURU   Quercus rubra \n 6    2614 NoCalC Berke… JBKMa…  28524 2     Park          EUGL   Eucalyptus gl…\n 7    2649 NoCalC Berke… JBKMa…  29288 2     Park          SESE   Sequoia sempe…\n 8    2840 NoCalC Berke… JBKMa…  70598 1     Park          EUGL   Eucalyptus gl…\n 9   12252 Piedmt Charl… CLTMa… 125399 F6    Street        QUAL   Quercus alba  \n10   13658 PacfNW Longv… Longv…   9192 -1    Park          POTR2  Populus balsa…\n# ℹ 45 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\n\n\nDistinct\nA last function worth mentioning for subsetting is the distinct function. As you might imagine, this pulls all unique values from a given column in a dataset, similarly to the unique function in Base R:\n\ndistinct(treeData,City)\n\n# A tibble: 17 × 1\n   City            \n   &lt;chr&gt;           \n 1 Modesto, CA     \n 2 Santa Monica, CA\n 3 Claremont, CA   \n 4 Berkeley, CA    \n 5 Glendale, AZ    \n 6 Fort Collins, CO\n 7 Minneapolis, MN \n 8 Indianapolis, IN\n 9 Queens, NY      \n10 Boise, ID       \n11 Albuquerque, NM \n12 Honolulu, HI    \n13 Charleston, SC  \n14 Charlotte, NC   \n15 Orlando, FL     \n16 Longview, WA    \n17 Sacramento, CA  \n\n\nA nice feature of this function is that it can be used with multiple columns to get the unique combinations of variables present in the data:\n\ndistinct(treeData,City,CommonName)\n\n# A tibble: 357 × 2\n   City        CommonName          \n   &lt;chr&gt;       &lt;chr&gt;               \n 1 Modesto, CA Silver maple        \n 2 Modesto, CA European white birch\n 3 Modesto, CA Chinese hackberry   \n 4 Modesto, CA Camphor tree        \n 5 Modesto, CA Raywood ash         \n 6 Modesto, CA Hesse ash           \n 7 Modesto, CA Moraine ash         \n 8 Modesto, CA Marshall ash        \n 9 Modesto, CA Modesto ash         \n10 Modesto, CA Ginkgo              \n# ℹ 347 more rows\n\n\n\n\n\n\n\n\nTry it yourself!\n\n\n\nYou can quickly get a complex subset by combining some of these functions. Using the tree data and the functions above, create the following datasets:\n\nThe database ID and all columns measured in meters for all trees in the Quercus genus\nThe database ID, Common Name, and DBH of the top 200 trees by leaf area in California\nThe database ID, scientific name, street name, and crown height for trees on located on an “Elm Street”\n\n\n\n\n\n\n\n\n\nStretch activity\n\n\n\nHow might you visualize some the datasets you just created? Add some visualizations of these datasets to your Quarto document.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with wrangling</span>"
    ]
  },
  {
    "objectID": "02_transforming.html",
    "href": "02_transforming.html",
    "title": "2  Transforming data",
    "section": "",
    "text": "Beyond subsetting, other functions from dplyr work to restructure the data by changing the arrangement of rows and columns, or by modifying their contents. Here, we’ll look at two kinds of operation: mutate and bind.\n\nMutate\nmutate is a useful function that creates new columns by calculating values from existing columns. For example, we can add a column of DBH values in inches this way:\n\ntreeData2&lt;-mutate(treeData,DBHin=`DBH (cm)` / 2.54)\ntreeData2\n\n# A tibble: 14,487 × 42\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 14,477 more rows\n# ℹ 33 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nHere we’ve created a new variable called DBHin by multiplying all the values in DBH (cm) by 2.54. We can also create new values by combining values across multiple columns. For example, if we wanted to get crown depth, which is the difference between the total tree height and the crown height, we can subtract these using a mutate function:\n\ntreeData3&lt;-mutate(treeData2,crownDepth_m=`TreeHt (m)`-`CrnHt (m)`)\nggplot(treeData3,aes(x=crownDepth_m)) + \n  geom_histogram()\n\n\n\n\n\n\n\n\nThe important thing to remember about these kinds of operations is that they are happening row-wise, so the values in the new column will correspond to the position of values in the columns used. For example, the first tree height value is 2 meters, while the first crown height value is 0.5. When the latter is subtracted from the former, we get a value of 1.5, and this becomes the first value in our new column.\n\n\nBind\nSometimes you may want to combine two datasets into a single table. Let’s say we had two tables of different maple trees:\n\nsugarMaples&lt;-filter(treeData,CommonName==\"Sugar maple\")\nredMaples&lt;-filter(treeData,CommonName==\"Red Maple\")\n\nWe can put these two together using the bind_rows function, which we’ve seen before in our lab exercise using the Rarotonga weather:\n\nmapleTrees&lt;-bind_rows(sugarMaples,redMaples)\n\nThe bind_cols function works similarly, but instead binds new columns to an existing table. For example, let’s say we had our maple tree data in two pieces; information about streets and information species names:\n\nmapleNames&lt;-select(mapleTrees,ends_with(\"Name\",ignore.case = TRUE))\nmapleStreets&lt;-select(mapleTrees,DbaseID,contains(\"Street\",ignore.case = FALSE))\n\nWe can recombine these using the bind_cols function this way:\n\nmapleData&lt;-bind_cols(mapleStreets,mapleNames)\nmapleData\n\n# A tibble: 246 × 7\n   DbaseID `Park/Street` OnStreet FromStreet ToStreet ScientificName CommonName \n     &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;          &lt;chr&gt;      \n 1    3936 Street        -1       -1         -1       Acer saccharum Sugar maple\n 2    4014 Street        -1       -1         -1       Acer saccharum Sugar maple\n 3    4101 Street        -1       -1         -1       Acer saccharum Sugar maple\n 4    4150 Street        -1       -1         -1       Acer saccharum Sugar maple\n 5    4206 Street        -1       -1         -1       Acer saccharum Sugar maple\n 6    4268 Street        -1       -1         -1       Acer saccharum Sugar maple\n 7    4295 Street        -1       -1         -1       Acer saccharum Sugar maple\n 8    4348 Street        -1       -1         -1       Acer saccharum Sugar maple\n 9    4353 Street        -1       -1         -1       Acer saccharum Sugar maple\n10    4371 Street        -1       -1         -1       Acer saccharum Sugar maple\n# ℹ 236 more rows\n\n\n\n\n\n\n\n\nTry it yourself!\n\n\n\nA distinguishing factor between the tidyverse bind_rows and its Base R equivalent (rbind) is that the Base R commands will only work with tables that have the same opposing dimension (same number of columns). The tidyverse versions will simply fill any unmatched columns or rows with NA values. Try it by combining the tree dataset with these datasets from the modeldata package:\n\ncrickets\npenguins\nSacramento",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Transforming data</span>"
    ]
  },
  {
    "objectID": "03_tidying.html",
    "href": "03_tidying.html",
    "title": "3  Tidying data",
    "section": "",
    "text": "In class, we will be discussing the principles of tidy data. These are:\n\neach variable is stored in its own column\neach observation is stored in its own row\neach cell contains a unique value\n\nThese seem pretty straightforward, but these simple rules are broken quite regularly, with data stored in column names, or multiple data types stored in a single column, or variables stored in both rows and columns. The tidyr package, again part of tidyverse, provides some key functions for dealing with these kinds of issues.\n\nPivot_longer\nOftentimes, categorical information you want to use is actually stored in the names of columns. For example, in the figure below, the leftmost table has three columns: country, 1999, and 2000 (where the numbers correspond to the number of cases of a disease for those countries in each of those years). But what if we were interested in making a visualization or conducting an analysis where the year was a variable of interest? Since year is not a column unto itself, but instead the years are stored across multiple column names, it’s not clear how this would be done.\n\n\n\n\n\nTo deal with this, we can gather the data in the 1999 and 2000 columns into two new columns: one the contains the years, and another with their associated number of cases. The new table, at right, is now twice as many rows; in the parlance of data tidying, it has been made longer. If we had more years in our dataset (e.g., 2001, 2002, etc) the length would be further multiplied.\n\nWe can see an example of this kind of issue in the tree dataset. The last 8 columns are values for DBH recorded across trees with multiple stems (up to 8). Not every tree will have 8 stems, so the table uses -1 to indicate an absence of these additional stems.\nLet’s say we were wondering whether the fieldworkers had a tendency to record stems randomly or according to size. The stem number is a piece of information we need to include in our assessment, but this is currently stored in the column names (e.g., dbh1, dbh2, etc.). We can use pivot_longer to turn each of these columns into a value in a single column:\n\nstemData&lt;-pivot_longer(\n  data=treeData,\n  cols=dbh1:dbh8,\n  names_to=\"stemNum\",\n  values_to=\"dbhMeasure\"\n)\n\nHere’s a breakdown of the arguments being used here:\n\ndata is the table being pivoted (in this case, treeData)\ncols is the columns where the names are going to be converted to data (in this case, columns dbh1 to dbh8). By separating the first and last column of interest with a colon (:), we’re telling the function we want these columns in sequential order. If you are using columns that are not adjacent to one another, you could substitute a vector of columns names.\nnames_to provides a name for a new column where the stem numbers (the column names) are going to be stored as data.\nvalues_to provides a name for a new column where the values from the columns we are converting will go.\n\nWhen we look at the new table, scroll all the way over to the right side to see the new columns:\n\nstemData\n\n# A tibble: 115,896 × 35\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 3       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 4       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 5       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 6       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 7       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 8       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 9       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n10       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n# ℹ 115,886 more rows\n# ℹ 26 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nNow, each stem number has its own line, as well as a corresponding dbh measurement. While we’re at it, we might want to eliminate the letters “dbh” from the stem number values. We can do this by adding an additional argument to the pivot_longer function: names_prefix.\n\nstemData&lt;-pivot_longer(\n  data=treeData,\n  cols=dbh1:dbh8,\n  names_to=\"stemNum\",\n  values_to=\"dbhMeasure\",\n  names_prefix = \"dbh\"\n)\n\nNow when we look at our data, we have a few less variables to deal with but a considerably larger number of observations:\n\nstemData\n\n# A tibble: 115,896 × 35\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 3       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 4       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 5       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 6       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 7       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 8       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 9       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n10       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n# ℹ 115,886 more rows\n# ℹ 26 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nWhat this data allows us to do more easily is use stem number itself as a variable. For example, we can now plot a boxplot to show how these stem numbers vary in terms of DBH measurements:\n\nstemData2&lt;-filter(stemData,dbhMeasure&gt;-1)\nggplot(stemData2,aes(x=stemNum,y=dbhMeasure)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nOverall, we can see that stem numbers 1 through 5 tend to decrease in the distribution of their DBH measurements, but after this it becomes less obvious that there is a trend. This makes some intuitive sense: trees with fewer stems tend to have wider diameters, especially those with only one or two stems, while trees with 5 or more stems may be more likely to be comprised of several small stems.\n\n\nPivot_wider\nThe opposite scenario from the one above involves taking data that is stored in a single column and spreading it across multiple columns. For example, in the figure below, the leftmost table has a column for type referring to the type of measurement. While not impossible, it’s difficult to see how we might use the category names cases and population in an analysis, but we may well want to understand the relationship between these two variables\n\n\n\n\n\nHere, we’ll use it to convert out tree data back into the format we’re used to:\n\ntreeWide&lt;-pivot_wider(\n  data=stemData,\n  names_from=stemNum,\n  values_from=dbhMeasure\n)\ntreeWide\n\n# A tibble: 14,487 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1       1 InlVal Modes… Motow…      1 Nurs… Nursery       ACSA1  Acer sacchari…\n 2       2 InlVal Modes… Motow…      2 Nurs… Nursery       BEPE   Betula pendula\n 3       3 InlVal Modes… Motow…      3 Nurs… Nursery       CESI4  Celtis sinens…\n 4       4 InlVal Modes… Motow…      4 Nurs… Nursery       CICA   Cinnamomum ca…\n 5       5 InlVal Modes… Motow…      5 Nurs… Nursery       FRAN_R Fraxinus angu…\n 6       6 InlVal Modes… Motow…      6 Nurs… Nursery       FREX_H Fraxinus exce…\n 7       7 InlVal Modes… Motow…      7 Nurs… Nursery       FRHO   Fraxinus holo…\n 8       8 InlVal Modes… Motow…      8 Nurs… Nursery       FRPE_M Fraxinus penn…\n 9       9 InlVal Modes… Motow…      9 Nurs… Nursery       FRVE_G Fraxinus velu…\n10      10 InlVal Modes… Motow…     10 Nurs… Nursery       GIBI   Ginkgo biloba \n# ℹ 14,477 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\n\n\nSeparate\nThe seperate function takes columns where there is more than one piece of information stored in each cell and breaks it up into multiple columns. For example, let’s say we wanted separate columns for the genus and species of the trees:\n\ntreeDataSep&lt;-separate(\n  data=treeData,\n  col=ScientificName,\n  into=c(\"Genus\",\"Species\"),\n  sep=\" \",\n  extra=\"drop\")\ntreeDataSep\n\n# A tibble: 14,487 × 42\n   DbaseID Region City    Source TreeID Zone  `Park/Street` SpCode Genus Species\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;  \n 1       1 InlVal Modest… Motow…      1 Nurs… Nursery       ACSA1  Acer  saccha…\n 2       2 InlVal Modest… Motow…      2 Nurs… Nursery       BEPE   Betu… pendula\n 3       3 InlVal Modest… Motow…      3 Nurs… Nursery       CESI4  Celt… sinens…\n 4       4 InlVal Modest… Motow…      4 Nurs… Nursery       CICA   Cinn… campho…\n 5       5 InlVal Modest… Motow…      5 Nurs… Nursery       FRAN_R Frax… angust…\n 6       6 InlVal Modest… Motow…      6 Nurs… Nursery       FREX_H Frax… excels…\n 7       7 InlVal Modest… Motow…      7 Nurs… Nursery       FRHO   Frax… holotr…\n 8       8 InlVal Modest… Motow…      8 Nurs… Nursery       FRPE_M Frax… pennsy…\n 9       9 InlVal Modest… Motow…      9 Nurs… Nursery       FRVE_G Frax… veluti…\n10      10 InlVal Modest… Motow…     10 Nurs… Nursery       GIBI   Gink… biloba \n# ℹ 14,477 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nThe arguments here should look familiar, but a couple may be worth discussing. The sep argument gives the symbol that separates the two sections. Here, the genus and species are separated by a single space, so we include that in quotes. The extra argument gives instructions on what to do with any extra data. If you look at the original tree data, you can see some scientific names have more than two parts. In this case, let’s assume we’re not too fussy about that, so we use the argument “drop” to get rid of it.\n\n\nUnite\nUnite is the opposite of separate. It simply takes two columns and puts them together, like so:\n\ntreeDataUnite&lt;-unite(\n  data=treeDataSep,\n  col=\"SciName\",\n  Genus:Species,\n  sep=\" \",\n  remove=TRUE)\ntreeDataUnite\n\n# A tibble: 14,487 × 41\n   DbaseID Region City        Source   TreeID Zone  `Park/Street` SpCode SciName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;  \n 1       1 InlVal Modesto, CA Motown2…      1 Nurs… Nursery       ACSA1  Acer s…\n 2       2 InlVal Modesto, CA Motown2…      2 Nurs… Nursery       BEPE   Betula…\n 3       3 InlVal Modesto, CA Motown2…      3 Nurs… Nursery       CESI4  Celtis…\n 4       4 InlVal Modesto, CA Motown2…      4 Nurs… Nursery       CICA   Cinnam…\n 5       5 InlVal Modesto, CA Motown2…      5 Nurs… Nursery       FRAN_R Fraxin…\n 6       6 InlVal Modesto, CA Motown2…      6 Nurs… Nursery       FREX_H Fraxin…\n 7       7 InlVal Modesto, CA Motown2…      7 Nurs… Nursery       FRHO   Fraxin…\n 8       8 InlVal Modesto, CA Motown2…      8 Nurs… Nursery       FRPE_M Fraxin…\n 9       9 InlVal Modesto, CA Motown2…      9 Nurs… Nursery       FRVE_G Fraxin…\n10      10 InlVal Modesto, CA Motown2…     10 Nurs… Nursery       GIBI   Ginkgo…\n# ℹ 14,477 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nThe last argument in this case, remove, takes away the now redundant columns of Genus and Species. In all of the functions above, the goal is to tackle common issues with data entry.\n\n\n\n\n\n\nTry it yourself!\n\n\n\nUse the separate and unite functions to do the following\n\nIn the tree dataset, create separate columns for city and state\nIn the Sacramento dataset, combine the longitude and latitude columns into a single column",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tidying data</span>"
    ]
  },
  {
    "objectID": "04_pipes.html",
    "href": "04_pipes.html",
    "title": "4  Pipes",
    "section": "",
    "text": "Connecting pipes outside of the tidyverse\nLet’s say we wanted to combine several of the preceding techniques to get a final dataset with the following transformations:\nWe’ve seen all of these techniques, and could write a code block that does all of it:\nAs you may have noticed, this process starts to get cumbersome, and keeping track of multiple objects with similar names can easily lead to errors. In an ideal world, our original dataset will pass through a series of transformations, producing an object with the desired changes, without having to store each iteration as .\nA helpful technique to streamline code and cut down on the number of objects being handled is to use the pipe (%&gt;%) operator. Pipes are used to create a flow from one function to the next in a series of transformations. The basic structure works something like this pseudocode below:\nnewObject&lt;-originalData %&gt;%  functionA(arguments) %&gt;%  functionB(arguments)\nHere, newObject will be where we assign the result of our transformations, and we put the dataset to be transformed (originalData) on the other side of the assignment operator (&lt;-). This is followed by a pipe1 (%&gt;%), which can be translated as “take the result of the preceding code and send it as the first argument in the next function”. Since the most of the tidyverse packages take a table as their first argument, the first pipe above sends the original data to functionA. The arguments given to the function do not include the dataset, but can refer to its variables by name. This result can be be piped into another function, and this process repeats until the data transformations are complete.\nLet’s try it with the same procedure above:\nThe above code uses less text overall, which means less redundant typing on your part, and is an example of an approach known as method chaining. It also has some qualities that help maintain organization. First, the process only requires a single assignment, and it only produces one object. Second, each transformation function is indented beneath this assignment, providing a clear outline of the processes used to modify the data (first filter, then select, etc.). This improves code readability, and makes it easier to keep track of how your data is changing.\nSo why didn’t it plot? The answer here is because the code is storing the ggplot output to the modestoMaplesPlot object. So we just need to call that object to see our plot:\nWhat about if the function doesn’t come from the tidyverse packages? Plenty of packages are written using Base R, so is there a way to integrate these into a pipeline?\nThe answer is: yes, but how it works depends on the function. If the function takes a table as it’s first argument, then it should work just fine. For example, the colMeans function, which calculates the mean for each column in a dataset:\nmodestoMaples %&gt;%\n  select(`DBH (cm)`,`TreeHt (m)`) %&gt;%\n  colMeans()\n\n  DBH (cm) TreeHt (m) \n  55.21379   16.34138\nBut many other functions assume the objects being given as the first arguments are something else. For example, let’s say we wanted to run a Spearman’s rank correlation on the relationship between DBH and tree height. We might write a pipeline that looks like this:\nmodestoMaples %&gt;%\n  cor.test(`DBH (cm)`,`TreeHt (m)`,method='spearman')\n\nError: object 'TreeHt (m)' not found\nThe problem here is that the cor.test function is expecting the first two arguments to be vectors, but it doesn’t know that the arguments correspond to columns in the tibble coming through the pipe. We need a way to tell R that we’re using the data from the pipeline in this function. To do this, we can wrap the Base R function in curly braces ({}) and then refer to columns in the tibble by preceding them with .$. The fullstop here (.) is a placeholder for the tibble being fed to the function:\nmodestoMaples %&gt;%\n  {cor.test(.$`DBH (cm)`,.$`TreeHt (m)`,method='spearman')}\n\nWarning in cor.test.default(.$`DBH (cm)`, .$`TreeHt (m)`, method = \"spearman\"):\nCannot compute exact p-value with ties\n\n\n\n    Spearman's rank correlation rho\n\ndata:  .$`DBH (cm)` and .$`TreeHt (m)`\nS = 154206, p-value &lt; 2.2e-16\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n      rho \n0.9259037\nWhile pipes are a convenience for many standard data-cleaning operations, they are by no means required. I recommend trying out some operations with and without pipes. You may end up deciding that these are not your cup of tea and sticking with what we’ve already covered.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pipes</span>"
    ]
  },
  {
    "objectID": "04_pipes.html#connecting-pipes-outside-of-the-tidyverse",
    "href": "04_pipes.html#connecting-pipes-outside-of-the-tidyverse",
    "title": "4  Pipes",
    "section": "",
    "text": "Try it yourself!\n\n\n\nUse the different tidyverse functions to create a pipeline to wrangle raw data into the desired form. The datasets are all in the modeldata package:\n\nBody mass and flipper length for penguins from Biscoe and Dream islands with a body mass over 400 grams.\nPrice, number of baths, and square meters for three-bedroom homes in the Roseville, Orangevale, and Citrus Heights neighborhoods of Sacramento.\nSpecies, year, and diameter (converted from mm to inches) for the top 20 predator scat by mass.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pipes</span>"
    ]
  },
  {
    "objectID": "04_pipes.html#footnotes",
    "href": "04_pipes.html#footnotes",
    "title": "4  Pipes",
    "section": "",
    "text": "This pipe operator is the original pipe from the magrittr package; another pipe operator, the Base R pipe, is also available, and looks like this |&gt;. They function more or less the same, but some sources will use one and some will use the other, so it’s a good idea to be familiar with both.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pipes</span>"
    ]
  },
  {
    "objectID": "05_summarize.html",
    "href": "05_summarize.html",
    "title": "5  Grouping and summarizing",
    "section": "",
    "text": "In this last section, we’re going to look at how we might perform operations on datasets based on a grouping variable. This , but rather than be part , this grouping will be used to\nLet’s start by creating a dataset of only Norway maples.\n\nnorwayMaples&lt;-treeData %&gt;%\n  filter(CommonName==\"Norway maple\") \nnorwayMaples\n\n# A tibble: 320 × 41\n   DbaseID Region City   Source TreeID Zone  `Park/Street` SpCode ScientificName\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n 1    3905 NMtnPr Fort … FNLMa…     26 -1    Street        ACPL   Acer platanoi…\n 2    3921 NMtnPr Fort … FNLMa…     38 -1    Street        ACPL   Acer platanoi…\n 3    3923 NMtnPr Fort … FNLMa…     41 -1    Street        ACPL   Acer platanoi…\n 4    3935 NMtnPr Fort … FNLMa…     55 -1    Street        ACPL   Acer platanoi…\n 5    3938 NMtnPr Fort … FNLMa…     61 -1    Street        ACPL   Acer platanoi…\n 6    3939 NMtnPr Fort … FNLMa…     63 -1    Street        ACPL   Acer platanoi…\n 7    4006 NMtnPr Fort … FNLMa…    124 -1    Street        ACPL   Acer platanoi…\n 8    4042 NMtnPr Fort … FNLMa…    150 -1    Street        ACPL   Acer platanoi…\n 9    4069 NMtnPr Fort … FNLMa…    181 -1    Street        ACPL   Acer platanoi…\n10    4070 NMtnPr Fort … FNLMa…    186 -1    Street        ACPL   Acer platanoi…\n# ℹ 310 more rows\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nGreat. Now let’s say we wanted to look at the top five of these trees in the whole dataset. We can do this by using the slice_max function we saw earlier:\n\ntop5&lt;-norwayMaples %&gt;%\n  slice_max(order_by=`TreeHt (m)`,n=5)\ntop5\n\n# A tibble: 7 × 41\n  DbaseID Region City    Source TreeID Zone  `Park/Street` SpCode ScientificName\n    &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n1    8077 TpIntW Boise,… BOIMa…   7283 2A    Street        ACPL   Acer platanoi…\n2   13812 PacfNW Longvi… Longv…  10823 -1    Street        ACPL   Acer platanoi…\n3    7081 NoEast Queens… JFKMa…  92007 55    Street        ACPL   Acer platanoi…\n4   13312 PacfNW Longvi… Longv…   2894 -1    Street        ACPL   Acer platanoi…\n5    7088 NoEast Queens… JFKMa…    346 409   Street        ACPL   Acer platanoi…\n6    7090 NoEast Queens… JFKMa…  27937 55    Street        ACPL   Acer platanoi…\n7   13330 PacfNW Longvi… Longv…   3142 -1    Street        ACPL   Acer platanoi…\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;,\n#   WireConf &lt;dbl&gt;, dbh1 &lt;dbl&gt;, dbh2 &lt;dbl&gt;, dbh3 &lt;dbl&gt;, dbh4 &lt;dbl&gt;, …\n\n\nInterestingly, this gave us 7 trees instead of 5. The reason for this becomes clear if we just look at the height column:\n\ntop5 %&gt;% select(`TreeHt (m)`)\n\n# A tibble: 7 × 1\n  `TreeHt (m)`\n         &lt;dbl&gt;\n1         27  \n2         26  \n3         25  \n4         24.5\n5         24  \n6         24  \n7         24  \n\n\nHere we see there is a three-way tie for 5th tallest tree. We can fix this by adding the argument with_ties = FALSE to our slice_max function:\n\ntop5&lt;-norwayMaples %&gt;%\n  slice_max(order_by=`TreeHt (m)`,n=5,with_ties = FALSE)\ntop5\n\n# A tibble: 5 × 41\n  DbaseID Region City    Source TreeID Zone  `Park/Street` SpCode ScientificName\n    &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;         \n1    8077 TpIntW Boise,… BOIMa…   7283 2A    Street        ACPL   Acer platanoi…\n2   13812 PacfNW Longvi… Longv…  10823 -1    Street        ACPL   Acer platanoi…\n3    7081 NoEast Queens… JFKMa…  92007 55    Street        ACPL   Acer platanoi…\n4   13312 PacfNW Longvi… Longv…   2894 -1    Street        ACPL   Acer platanoi…\n5    7088 NoEast Queens… JFKMa…    346 409   Street        ACPL   Acer platanoi…\n# ℹ 32 more variables: CommonName &lt;chr&gt;, TreeType &lt;chr&gt;, address &lt;chr&gt;,\n#   street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;, FromStreet &lt;chr&gt;,\n#   ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;, `TreeHt (m)` &lt;dbl&gt;,\n#   CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;,\n#   WireConf &lt;dbl&gt;, dbh1 &lt;dbl&gt;, dbh2 &lt;dbl&gt;, dbh3 &lt;dbl&gt;, dbh4 &lt;dbl&gt;, …\n\n\nThat’s better. Now, let’s say we wanted to see the top 5 from each state. We’ll need to use the separate function we saw earlier to get State into it’s own column. But after this, we’ll use the group_by function to group the data based on this new column:\n\nstateNorways&lt;-norwayMaples %&gt;%\n  separate(col=City,into=c(\"City\",\"State\"),sep=\", \", extra=\"drop\") %&gt;%\n  group_by(State) \n\nstateNorways\n\n# A tibble: 320 × 42\n# Groups:   State [6]\n   DbaseID Region City         State Source    TreeID Zone  `Park/Street` SpCode\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt; \n 1    3905 NMtnPr Fort Collins CO    FNLMaste…     26 -1    Street        ACPL  \n 2    3921 NMtnPr Fort Collins CO    FNLMaste…     38 -1    Street        ACPL  \n 3    3923 NMtnPr Fort Collins CO    FNLMaste…     41 -1    Street        ACPL  \n 4    3935 NMtnPr Fort Collins CO    FNLMaste…     55 -1    Street        ACPL  \n 5    3938 NMtnPr Fort Collins CO    FNLMaste…     61 -1    Street        ACPL  \n 6    3939 NMtnPr Fort Collins CO    FNLMaste…     63 -1    Street        ACPL  \n 7    4006 NMtnPr Fort Collins CO    FNLMaste…    124 -1    Street        ACPL  \n 8    4042 NMtnPr Fort Collins CO    FNLMaste…    150 -1    Street        ACPL  \n 9    4069 NMtnPr Fort Collins CO    FNLMaste…    181 -1    Street        ACPL  \n10    4070 NMtnPr Fort Collins CO    FNLMaste…    186 -1    Street        ACPL  \n# ℹ 310 more rows\n# ℹ 33 more variables: ScientificName &lt;chr&gt;, CommonName &lt;chr&gt;, TreeType &lt;chr&gt;,\n#   address &lt;chr&gt;, street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;,\n#   FromStreet &lt;chr&gt;, ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;,\n#   `TreeHt (m)` &lt;dbl&gt;, CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nLook at the top left line in that tibble printout. The dimensions are identical to that produced by norwayMaples, but next to the dimensions, it says Groups: State [6]. This means that any operations performed on this table now will be done group-wise, or applied to each group separately. For example, let’s try and get our top five trees by height again:\n\ntop5&lt;-stateNorways %&gt;%\n  slice_max(order_by=`TreeHt (m)`,n=5,with_ties = FALSE)\ntop5\n\n# A tibble: 30 × 42\n# Groups:   State [6]\n   DbaseID Region City         State Source    TreeID Zone  `Park/Street` SpCode\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt; \n 1    4591 NMtnPr Fort Collins CO    FNLMaste…   1327 -1    Street        ACPL  \n 2    4475 NMtnPr Fort Collins CO    FNLMaste…    918 -1    Street        ACPL  \n 3    4598 NMtnPr Fort Collins CO    FNLMaste…   1352 -1    Street        ACPL  \n 4    4179 NMtnPr Fort Collins CO    FNLMaste…    347 -1    Street        ACPL  \n 5    4439 NMtnPr Fort Collins CO    FNLMaste…    823 -1    Street        ACPL  \n 6    8077 TpIntW Boise        ID    BOIMaste…   7283 2A    Street        ACPL  \n 7    8265 TpIntW Boise        ID    BOIMaste…  14627 4A    Street        ACPL  \n 8    8277 TpIntW Boise        ID    BOIMaste…  14970 4A    Street        ACPL  \n 9    8762 TpIntW Boise        ID    BOIMaste…  70013 JJ    Street        ACPL  \n10    8239 TpIntW Boise        ID    BOIMaste…  13630 4A    Street        ACPL  \n# ℹ 20 more rows\n# ℹ 33 more variables: ScientificName &lt;chr&gt;, CommonName &lt;chr&gt;, TreeType &lt;chr&gt;,\n#   address &lt;chr&gt;, street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;,\n#   FromStreet &lt;chr&gt;, ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;,\n#   `TreeHt (m)` &lt;dbl&gt;, CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nNotice this time that, rather than have a tibble with 5 rows, we have one with 30 rows: 5 trees for each of the 6 states represented.\n\nSummarize\nThis grouping technique is especially useful when combined with another function: summarize. This function calculates summary statistics (mean, standard deviation, etc.) for a set of data. Here’s what it looks like for the ungrouped Norway maple data:\n\nnorwayMapleStats&lt;-norwayMaples %&gt;%\n  summarize(n=n(),meanHt=mean(`TreeHt (m)`),sd=sd(`TreeHt (m)`)) \nnorwayMapleStats\n\n# A tibble: 1 × 3\n      n meanHt    sd\n  &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1   320   13.1  5.42\n\n\nLet’s breakdown each of these arguments in the summarize function individually.\n\nn=n() This counts the number of rows in the data and stores it in a column labeled n.\nmeanHt=mean(`TreeHt (m)`) This calculates the mean of the tree heights and stores it in a column called meanHt.\nsd=sd(`TreeHt (m)`) This calculates the standard deviation of the tree heights and stores it in a column called sd.\n\nThe result is a table with a single row, calculating each of the above for the entire dataset. Now let’s try the same thing on our grouped data:\n\nstateNorwayStats&lt;-stateNorways %&gt;%\n  summarize(n=n(),meanHt=mean(`TreeHt (m)`),sd=sd(`TreeHt (m)`)) \n\nstateNorwayStats\n\n# A tibble: 6 × 4\n  State     n meanHt    sd\n  &lt;chr&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 CO       60   13.3  4.45\n2 ID       62   12.8  5.08\n3 IN       34   12.3  5.27\n4 MN       48   10.6  3.98\n5 NY       42   12.6  6.52\n6 WA       74   15.5  5.83\n\n\nWhat end up with is the same set of summary statistics, but calculated for each state.\n\n\nUngrouping\nThere are sometimes situtations where you may need to add a grouping to a dataset and then remove it later. The function for removing a grouping is ungroup:\n\nstateNorways&lt;-ungroup(stateNorways)\nstateNorways\n\n# A tibble: 320 × 42\n   DbaseID Region City         State Source    TreeID Zone  `Park/Street` SpCode\n     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt; \n 1    3905 NMtnPr Fort Collins CO    FNLMaste…     26 -1    Street        ACPL  \n 2    3921 NMtnPr Fort Collins CO    FNLMaste…     38 -1    Street        ACPL  \n 3    3923 NMtnPr Fort Collins CO    FNLMaste…     41 -1    Street        ACPL  \n 4    3935 NMtnPr Fort Collins CO    FNLMaste…     55 -1    Street        ACPL  \n 5    3938 NMtnPr Fort Collins CO    FNLMaste…     61 -1    Street        ACPL  \n 6    3939 NMtnPr Fort Collins CO    FNLMaste…     63 -1    Street        ACPL  \n 7    4006 NMtnPr Fort Collins CO    FNLMaste…    124 -1    Street        ACPL  \n 8    4042 NMtnPr Fort Collins CO    FNLMaste…    150 -1    Street        ACPL  \n 9    4069 NMtnPr Fort Collins CO    FNLMaste…    181 -1    Street        ACPL  \n10    4070 NMtnPr Fort Collins CO    FNLMaste…    186 -1    Street        ACPL  \n# ℹ 310 more rows\n# ℹ 33 more variables: ScientificName &lt;chr&gt;, CommonName &lt;chr&gt;, TreeType &lt;chr&gt;,\n#   address &lt;chr&gt;, street &lt;chr&gt;, side &lt;chr&gt;, cell &lt;dbl&gt;, OnStreet &lt;chr&gt;,\n#   FromStreet &lt;chr&gt;, ToStreet &lt;chr&gt;, Age &lt;dbl&gt;, `DBH (cm)` &lt;dbl&gt;,\n#   `TreeHt (m)` &lt;dbl&gt;, CrnBase &lt;dbl&gt;, `CrnHt (m)` &lt;dbl&gt;, `CdiaPar (m)` &lt;dbl&gt;,\n#   `CDiaPerp (m)` &lt;dbl&gt;, `AvgCdia (m)` &lt;dbl&gt;, `Leaf (m2)` &lt;dbl&gt;,\n#   Setback &lt;dbl&gt;, TreeOr &lt;dbl&gt;, CarShade &lt;dbl&gt;, LandUse &lt;dbl&gt;, Shape &lt;dbl&gt;, …\n\n\nThe grouping process is particularly helpful with problems related to scale and aggregation. Imagine, for example, if you had one dataset recorded at the town level, and another at the county level. If you can connect towns to counties, you can aggregate the finer scale data to the broader scale.\nThere are a lot more variations on the techniques employed in the tidyverse to make the process of data wrangling more effective and less time consuming, but hopefully by now you’re starting to get the idea. As we go on, you’ll find more ways to make these work with different kinds of data. But for now, head over to today’s lab exercise for some additional practice.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Grouping and summarizing</span>"
    ]
  }
]
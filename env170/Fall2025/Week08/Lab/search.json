[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Graphing Like You Mean It",
    "section": "",
    "text": "Introduction\nSo far, we’ve mostly built graphs for our own purposes of looking at data and understanding patterns. For example, we can better understand the prices of homes in a city by plotting their distribution as a histogram. We can get a finer understanding of factors contributing to that distribution by separating the data by categories like education, income level, or race and looking at home prices in those categories as boxplots. Here, the choices we make are determined largely by the kind of data we have and the kind of patterning we want to see.\nHowever, data visualization is not limited to making data visible to us, the data scientists, but is also used for presenting data in a way that facilitates understanding and encourages engagement from others. Different color choices may better clarify trends across a dataset. Different layouts may make their incorporation in decision-making easier. Different emphasis may be more effective at prompting action.\nggplot2 and additional packages offer ways to change the look and feel of a graph in many ways that can help us to better communicate our ideas. In this lab, we will work on ways to control the visual appearance of graphs in order to achieve different goals.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01_CustomizingScales.html",
    "href": "01_CustomizingScales.html",
    "title": "1  Distinguishing palettes: Working with discrete scales in ggplot2",
    "section": "",
    "text": "Working with discrete color\nWhen working with color scales in ggplot2, the general pattern for the functions works something like this:\nscale_color_*\nscale_fill_*\nWhere the * refers to the method that will be used. So far, you may have seen the functions scale_color_manual and scale_fill_manual which let us control the colors in the plot manually via a vector of color values (e.g, c(\"red\",\"blue\",\"\"green\")). However, there are many additional options for manipulating the colors used in the plots that take advantage of the structure of the underlying data.\nDiscrete color scales are used when there are a set number of colors being used. For example, if you have 8 different categories in a variable, you might use 8 different colors to represent them.\nWhen dealing with different colors, we need to consider how those colors work together within the context of visualizing data. Whether as outline color or fill, a major consideration is the extent of overlap, and how that overlap is presented visually. Here, we’ll try a few different plots to demonstrate this before revising the color scheme.\nFor this section, we’ll use the penguin data and look at how one variable, body mass, varies across the three species. Since body mass is a continuous variable, it would make sense to plot this using a histogram. First, let’s see what it looks like for the population as a whole:\nlibrary(palmerpenguins)\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g)) +\n  geom_histogram()\nLooks good. Now what happens if we want to break this up by species? One option always available to us might be to use facets:\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g)) +\n  geom_histogram() +\n  facet_wrap(vars(species))\nThis works pretty well, but what if we wanted to show them all on the same graph? We could try mapping species on to the fill color of the bars:\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_histogram()\nThis looks OK, but there are some issues. For example, look at the bars around 4500 g: from top to bottom they are always in the same order as those in the legend. Why is this?\nWhat’s happening here is that this histogram, rather than dividing these into three overlapping histograms each with it’s own fill color, there is only one histogram for all penguins, but the bars are divided into the components represented by each species. This can be a little misleading, since it gives the impression that values read on the y-axis can be translated directly to the species we are interested in.\nLet’s try this again, but add a position argument to geom_histogram to change how it plots overlapping objects:\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_histogram(position=\"identity\")\nWhat’s happening here? Most of the different geoms each comes with a default way to deal with overlapping elements. In the case of geom_histogram, the default is position=\"stack\", which will put overlapping bars on top of one another vertically. But now we’ve changed it to position=\"identity\", which basically means “don’t modify the position of the elements”. Because of this, each species histogram is plotted in place, causing them to overlap. The species plotted first (Adelie) is plotted furthest in the back. We can see this more clearly if we add an alpha argument to make the bars semi-transparent:\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_histogram(position=\"identity\",alpha=0.7)\nNow we can see the three histograms, but there’s still some issues; in particular, it’s difficult to discern in all cases what combinations of two or three colors are overlapping.\nAnother option would be to use geom_freqpoly, which means frequency polygons. This creates a line chart (actually an unfilled polygon) that gives the outlines of the histogram.\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,color=species)) +\n  geom_freqpoly()\nNote that we shifted from an aesthetic mapping of species from fill to color, since geom_freqpoly is dealing with outlines rather than filled colors.\nThis is clearer in terms of delineating the shape of the distribution, but again there are some issues where overlaps occur in the lines. In addition, the use of lines here, and the appearance of jagged peaks, gives the impression of data with a sequential (time-based) relationship, which is not the case for penguin body mass.\nYet another option are density plots. These are like histograms, but instead of representing continuous data as binned values in a series of bars, it uses a smoothing procedure to show the distribution of values as their density, or probability of being selected from the population:\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density()\nBy default, the density values on the y-axis are the probability of a penguin’s body mass in that species to occur at a given measurement, based on the values provided in the data. If you summed the area under each of these curves, it would equal 1, because, based on our sample, all penguin body masses should fall in this range.\nThe numbers on this axis are quite small, so they are being expressed in scientific notation. And because they are calculated specific to the species, this changes the the heights with respect to the histogram; for example, the height of the Chinstrap penguins (the least well represented group in the dataset) curve suddenly seems a lot larger.\nThey’re also calculated specific to the species, which is why the height of the Chinstrap penguins (the least well represented group in the dataset) curve suddenly seems a lot larger. We can scale the density to the size of the group using the after_stat function for the aesthetic mapping of the y variable, and ask it to use count, which gives us, roughly speaking, the proportional relationship between penguins of a given body size among all those in the data:\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,y=after_stat(count),fill=species)) +\n  geom_density()\nWhile the outcome says count, what this actually means is density multiplied by number of data observations, or the density scaled to the number of observations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Distinguishing palettes: Working with discrete scales in ggplot2</span>"
    ]
  },
  {
    "objectID": "01_CustomizingScales.html#predefined-discrete-color-scales",
    "href": "01_CustomizingScales.html#predefined-discrete-color-scales",
    "title": "1  Distinguishing palettes: Working with discrete scales in ggplot2",
    "section": "Predefined discrete color scales",
    "text": "Predefined discrete color scales\nR comes with several predefined options for dealing with discrete color scales. We’ll discuss a few options here:\n\nColorBrewer\nColorBrewer is a tool developed set of color schemes, or palettes, that were originally developed for making thematic (choropleth) maps more readable. These palettes can also be used for making plotting colors more effective as well. These are built into ggplot via the RColorBrewer package. We can get a look at these different palettes by loading that package and using the display.brewer.all function\n\nlibrary(RColorBrewer)\ndisplay.brewer.all(type=\"seq\")\n\n\n\n\n\n\n\ndisplay.brewer.all(type=\"div\")\n\n\n\n\n\n\n\ndisplay.brewer.all(type=\"qual\")\n\n\n\n\n\n\n\n\nThe three different type arguments used here (“seq”, “div”, and ““qual”“) refer to types of palettes that are useful for different applications:\n\nSequential: These colors go follow a light-to-dark pattern, and are used for ordered data (e.g., number of coal-burning power-plants in a country)\nDiverging: Critical values at both ends, useful when the emphasis is on deviation from a central value (e.g., is the median home price in a county higher or lower than the national average?)\nQualitative: No meaningful order or value, colors are used to gen (e.g., bony fish species observed in a reef)\n\nThe text at the left of each palette being displayed is the shorthand name used by RColorBrewer to refer to that specific palette. A subset of these are also color vision deficiency friendly:\n\ndisplay.brewer.all(type=\"all\",colorblindFriendly = TRUE)\n\n\n\n\n\n\n\n\nThe scale_color_brewer() function lets us use these palettes in our plots:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density() +\n  scale_fill_brewer(type=\"qual\",palette = 1)\n\n\n\n\n\n\n\n\nThe palette argument used here refers to the position of the palette within that type of palette (i.e., the first palette in the “qual” type). However, if you know which specific palette you want to use, you can skip the type argument and refer to the palette by name:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density() +\n  scale_fill_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\n\n\nViridis\nAdditional R packages provide more palettes. For example, the viridis package provides a set of palettes that are colorful, uniform (distance in value = distance in color), and robust to color vision deficiency. To access these, we need to load the viridis package first.\n\nlibrary(viridis)\n\nThe palettes provided by the viridis package can be viewed here. The names of each palette are accessed using the option argument. We can view a set of colors from the mako palette using the viridis_pal function:\n\nviridis_pal(option=\"mako\")(12)\n\n [1] \"#0B0405FF\" \"#231526FF\" \"#35264CFF\" \"#403A75FF\" \"#3D5296FF\" \"#366DA0FF\"\n [7] \"#3487A6FF\" \"#35A1ABFF\" \"#43BBADFF\" \"#6CD3ADFF\" \"#ADE3C0FF\" \"#DEF5E5FF\"\n\n\nThis is a strange-looking function call, since the number of color values is actually requested outside of the function’s parentheses. These are not common in R or tidyverse, but do occasionally come up. What it gives us back is a vector containing the hexidecimal codes for 12 equally-spaced color values across this palette.\nOf course, most of us don’t immediately know what colors correspond to different hexidecimal codes. To see what these look like, we can put this whole thing in the show_col function from the scales package.\n\nlibrary(scales)\nshow_col(viridis_pal(option=\"mako\")(12))\n\n\n\n\n\n\n\n\nWe can use this to quickly look at other palettes as well and choose one we like. For example, the magma palette:\n\nlibrary(scales)\nshow_col(viridis_pal(option=\"magma\")(12))\n\n\n\n\n\n\n\n\nFor plotting, let’s stick with the original viridis scheme, which goes from a deep purple to a bright yellow. To use this on the fill color, we would use the scale_fill_viridis_d function:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density() +\n  scale_fill_viridis_d(option=\"viridis\")\n\n\n\n\n\n\n\n\nWhy “d”? This is telling us that we are using colors for a discrete application. There is also scale_fill_viridis_c for continuous data and scale_fill_viridis_b for binned data.\n\n\nAdditional fine-tuning\nThis plot looks OK, but we can’t really see what’s going on in the overlapping sections, so we might want to change the transparency so we can see what’s going on behind the Gentoo distribution. Again, plot transparency is accessed using the alpha argument, which can be supplied directly to the geom being modified:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5) +\n  scale_fill_viridis_d(option=\"viridis\")\n\n\n\n\n\n\n\n\nNow the shape of the distributions comes into clearer view. The 0.5 value here is a half-way point between completely opaque (1) and complete transparent (0). You can modify this value to get the look you want.\nYou may also want to change the outline colors as well. To get at these, we need to add color to our aesthetic mapping, and map it to species:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species,color=species)) +\n  geom_density(alpha=0.5) +\n  scale_fill_viridis_d(option=\"viridis\") \n\n\n\n\n\n\n\n\nOops! This is still drawing using the default color scheme. To get them to match, we’d need to add the scale_color_viridis_d function to modify color in addition to fill:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species,color=species)) +\n  geom_density(alpha=0.5) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  scale_color_viridis_d(option=\"viridis\")\n\n\n\n\n\n\n\n\nNot bad. Another approach might be to just drop the outlines by removing the color argument from the aesthetic mapping and then adding color=NA to the geom arguments:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA) +\n  scale_fill_viridis_d(option=\"viridis\")\n\n\n\n\n\n\n\n\nThis looks pretty good. To finish our plot, we can switch the theme to one with less grey in the background (theme_bw), and add our labels.\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTry it yourself!\n\n\n\nTry the other color schemes in the viridis package with the plot above and see how it looks. Do some color schemes work better than others?\n\n\n\n\nGreyscale\nA final way to which avoids issues with color vision deficiencies is to plot in greyscale. The function you would use is scale_fill_grey. For example:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=species,fill=species)) +\n  geom_bar() +\n  scale_fill_grey(start=0,end=1)\n\n\n\n\n\n\n\n\nThe start and end arguments refer to where on the scale of black (0) to white (1) you want the first and last values in your mapped variable. So here, since Adelie is the first species, it is given in black, and Gentoo, being the last, is in white.\nWe can see what this looks like in our density plot by replacing the viridis fill with the grey fill:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA) +\n  scale_fill_grey(start=0,end=1) +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")\n\n\n\n\n\n\n\n\nObviously, this has some issues. For example, we can’t see white on the white background from our theme. One way to deal with this would be to change the theme again; however, other shades of background might be equally problematic.\nAnother way would be to set different start and end values so that all of the values end up being some shade of grey:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA) +\n  scale_fill_grey(start=0.2,end=0.8) +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")\n\n\n\n\n\n\n\n\nThis solved one problem, but created another: it’s hard to distinguish places with overlap, particularly with the Adelie and Chinstrap penguins. We could help distinguish these by eliminating the transparency and adding the black outlines back in:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density() +\n  scale_fill_grey(start=0.2,end=0.8) +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")\n\n\n\n\n\n\n\n\nThis is probably about as good as it is going to get for a greyscale plot with overlap: here, we’ve sacrificed the visibility of data in the the back of the image for clarity distinguishing between categories. Going through this process highlights tradeoffs you might need to make when using this kind of plot. The layering of different polygons atop one another can help to show different distributions simultaneously, but it can also be source of confusion where overlaps and transparencies are concerned. It’s important to make sure when you’re plotting to consider whether someone might be able to read the graph without too much confusion.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Distinguishing palettes: Working with discrete scales in ggplot2</span>"
    ]
  },
  {
    "objectID": "02_CustomizingScalesPt2.html",
    "href": "02_CustomizingScalesPt2.html",
    "title": "2  Expanding palettes: Working with continuous scales in ggplot2",
    "section": "",
    "text": "Continuous color scales\nAs opposed to discrete color scales, continuous scales are used when the data exist across a range with no meaninfgul gaps between values. For example, you could have an infinite number of unique values even between the interval between 0 and 1. There are no discrete groups, breaks, or categories. From a color perspective, these are usually expressed in terms of a color ramp or gradient, where there is a smooth transition of values across a color spectrum.\nTo view some options for these kind of scales, we’ll use the gapminder data, but we’ll use the geom_tile function to create a heatmap.\n\nlibrary(gapminder)\n\nWarning: package 'gapminder' was built under R version 4.5.1\n\n#plot life expectancy by continent and year as heat map\nggplot(gapminder,aes(x=continent,y=year,fill=lifeExp)) +\n  geom_tile() +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\")\n\n\n\n\n\n\n\n\nA heatmap takes values at intersections between the x and y axes and places a tile (polygon) that is colored according to the continuous variable of interest. This can be useful for viewing a lot of data across a space of values. However, it’s usually more readable when the data are organized somehow. The ordering of the years makes sense here, but let’s reorder the continents based on median life expectancy:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\")\n\n\n\n\n\n\n\n\nThis makes things a little clearer, in the sense that continents with lower life expectancy are organized to the left, while those with higher average life expectancy are on the right. But the distinctions between values is a little muddled. We can try to get a better picture by modifying the gradients.\n\n\nCustom gradients\nThe default gradient ggplot uses runs from dark to light blue (also known as the Blues palette). What if we wanted to look at this using a different color scheme? Let’s start with the old stand-by: temperature colors. If we wanted the scale to go from red to blue, we could use the scale_color_gradient function. This takes two arguments: low defines the color used for the lowest value, and high defines the highest:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradient(low=\"blue\",high=\"red\") +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\")\n\n\n\n\n\n\n\n\nIf we wanted to invert them, all we have to do is switch the colors we use for low and high:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradient(low=\"red\",high=\"blue\") +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\")\n\n\n\n\n\n\n\n\nWhile we’re making changes, we probably don’t even need the grey background, so we can eliminate it with theme_minimal:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradient(low=\"red\",high=\"blue\") +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nBy the way, if you’re wondering about the various themes, here is a good directory of the different theme functions.\n\n\n\n\n\n\nTry it yourself!\n\n\n\nTry plotting this plot or the density plot from the previous section using some different themes. For example:\n\ntheme_linedraw()\ntheme_dark()\ntheme_void()\n\nThere are even more themes to choose from if you add the ggthemes package. Load this package (install first if you need to), and then explore a few more!\n\n\nFor some data like temperatures, the scheme above seems like it might work well, but for looking at life expectancy data, our color scheme is a little underwhelming. It’s hard to know, for example, how each continent compares to the others.\nWe can get a better sense of this by using a diverging palette: one that varies in two directions away from a central value. First, let’s get the overall median value for the lifeExp variable to be a central value:\n\nmedLE&lt;-median(gapminder$lifeExp)\nmedLE\n\n[1] 60.7125\n\n\nWe can use gradients that are scaled with a midpoint value using the scale_fill_gradient2 function (the “2” meaning “2-way”). This works pretty much the same way, but we add a midpoint argument to define the value (here we’ll use the medLe object we just created), and a mid argument to represent the color to be used at the midpoint of the gradient:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradient2(low=\"red\",mid=\"yellow\",high=\"darkgreen\",midpoint=medLE) +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nNow our map is getting more visually coherent. We can now see more clearly, for example, the values that each country starts and ends with, which gives us a better sense of the change that’s occurring over time.\nYet another alternative would be to scale between more one midpoint. To do this, we’d use the scale_fill_gradientn function (“n” standing for a number of midpoint breaks to be defined). Let’s say we wanted it done on a spectrum from red to blue, with addition breaks at the intermediate colors (orange, yellow, and green). We can do this by passing the colors argument\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradientn(colors = c(\"red\",\"orange\",\"yellow\",\"green\",\"blue\")) +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nIf you don’t want to use equally spaced divisions between the midpoints, you can set custom breaks by adding a values argument, that is expresses the ranges that each color is meant to be mapped on to. For example, let’s say you wanted to weight the color scale so the red end of the spectrum covered a wider range of values. You could do something like this:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradientn(colors = c(\"red\",\"orange\",\"yellow\",\"green\",\"blue\"),values=c(0,0.5,0.7,0.8,0.9,1))  +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nThe values argument here is a vector of numbers between 0 and 1 that represent breaks along the space between the minimum and maximum age. By setting wider intervals (like 0 - 0.5) for the red-orange transition, it weights\nHowever, using values like 0 and 0.5 isn’t especially intuitive if you’re thinking about this in terms of people’s ages on a scale of between 30ish and 85ish. A quick way around this is to use the rescale function (part of the scales package), which will take a vector of values and transform it into values scaled to a range of 0 to 1:\n\nlibrary(scales)\nrescaledLE&lt;-rescale(c(30,50,65,70,75,85),to=c(0,1))\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradientn(colors = c(\"red\",\"orange\",\"yellow\",\"green\",\"blue\"),values=rescaledLE)  +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nColorBrewer\nTo make use of the ColorBrewer palettes we saw in the previous section, you can use the scale_fill_distiller (“distiller” being a play on the word “brewer”), again defining the palette with the argument palette:\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_distiller(palette = \"YlOrBr\")  +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nOther packages\nFinally, there are additional packages that have been developed to provide palettes with far less serious agendas. I’ll mention the wesanderson package, which draws inspiration from the color schemes of Wes Anderson films. Here, we’ll draw on a palette from the film The Life Aquatic with Steve Zissou:\n\n\n\n\n\nTo do this, we’ll first load the package, then create a continuous palette object using the wes_palette function:\n\nlibrary(wesanderson) \n\nWarning: package 'wesanderson' was built under R version 4.5.1\n\npal&lt;-wes_palette(\"Zissou1\", n = 100, type = \"continuous\") \npal\n\n\n\n\n\n\n\n\nThe pal object we created provides a continuous palette along a diverging blue-red palette with a bright yellow as at the middle, consistent with the color scheme in that film. The n=100 argument determines how many divisions (bins) we should divide the palette along. A higher number would make finer scale color distinctions, while a lower number would make more distinct differences between values.\nNow we can replot our Gapminder data using the same color scheme.\n\nggplot(gapminder,aes(x=reorder(continent,lifeExp,fun=median),y=year,fill=lifeExp)) +\n  geom_tile() +\nscale_fill_gradientn(colors = pal)  +\n  labs(x=\"Continent\",y=\"Year\",fill=\"Life \\nExpectancy \\n(years)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nBy the way, I know we’ve seen most of these examples using fill as the aesthetic we are scaling. We can also do this with any use of the color aesthetic as well. All we need to do in this case would be to choose a geom that uses color and then change the name of the scale function from a scale_fill to a scale. For example, if we wanted to look at our penguin data as a scatterplot using the Zissou1 gradient, we can change the geom to geom_point and switch to the scale_color_gradientn function:\n\nggplot(drop_na(penguins,body_mass_g,flipper_length_mm, bill_length_mm),aes(x=body_mass_g,y=flipper_length_mm, color=bill_length_mm)) +   \n  geom_point() +   \n  scale_color_gradientn(colors=pal) +\n  labs(x=\"Body Mass (g)\",y=\"Flipper length (mm)\",color=\"Bill Length \\n(mm)\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Expanding palettes: Working with continuous scales in ggplot2</span>"
    ]
  },
  {
    "objectID": "03_CustomizingLabels.html",
    "href": "03_CustomizingLabels.html",
    "title": "3  Customizing Labels",
    "section": "",
    "text": "Putting labels on things: the annotate function\nReturning to our penguin plot from section 1:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")\n\n\n\n\n\n\n\n\nLet’s say that we’re finding the legend on the right hand side to be kind of distracting. We could use the show.legend argument under the geom_density function to remove it altogether:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA,show.legend = FALSE) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")\n\n\n\n\n\n\n\n\nHowever, now we don’t know what distribution corresponds to what species. One way we could deal with this would be to add labels to the distributions in the image. We can add individual labels to items using the annotate function:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA,show.legend = FALSE) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")+\n  annotate(geom=\"label\",x=3650,y=0.0009,label=\"Adelie\") +\n  annotate(geom=\"label\",x=3600,y=0.0005,label=\"Chinstrap\") +\n  annotate(geom=\"label\",x=5100,y=0.0004,label=\"Gentoo\")\n\n\n\n\n\n\n\n\nLet’s break down the arguments here for each of these annotate functions:\n\ngeom This tells us what kind of geometry to use. In this case, we’ll use the label geom, but other options are arrows, line segments, points, etc.\nx, y This gives the x and y position for the center of the label\nlabel This is the text that will be included in the label\n\nThese look pretty good. But let’s say we want to plot the labels using the same colors from the viridis palette. Annotation colors can be modified using the color function, but first we need to know what our colors names are. We did this earlier with the show_col and viridis_pal functions, but since we’re only looking at three categories here, we only need to request three colors:\n\nshow_col(viridis_pal()(3))\n\n\n\n\n\n\n\n\nThese are the hexidecimal codes for the colors we’re using. We can add them to the annotate function using the color argument and giving each one as a character value (e.g., “#440154FF”), but typing each of these codes out would be pain.\nAnother way we could do this would be to store them as a vector of values by skipping the show_col function:\n\nmyCols&lt;-viridis_pal()(3)\nmyCols\n\n[1] \"#440154FF\" \"#21908CFF\" \"#FDE725FF\"\n\n\nRemember way back when we learned about vectors and how to access individual values? That’s right, we’re going to use square brackets ([])! We can use the indices of each value in the myCols vector for each of the annotate calls:\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA,show.legend = FALSE) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")+\n  annotate(geom=\"label\",x=3650,y=0.0009,label=\"Adelie\",color=myCols[1]) +\n  annotate(geom=\"label\",x=3600,y=0.0005,label=\"Chinstrap\",color=myCols[2]) +\n  annotate(geom=\"label\",x=5100,y=0.0004,label=\"Gentoo\",color=myCols[3])\n\n\n\n\n\n\n\n\nNow we’ve run into a problem, though: the dreaded yellow-on-white. There are a few ways you might tackle this (changing the theme, changing the fill of the annotation label, etc.), but here we might try getting away with choosing a slightly darker yellow to offset the color.\n\n#plot body mass by species\nggplot(drop_na(penguins),aes(x=body_mass_g,fill=species)) +\n  geom_density(alpha=0.5,color=NA,show.legend = FALSE) +\n  scale_fill_viridis_d(option=\"viridis\") +\n  theme_bw() +\n  labs(x=\"Body mass (g)\",y=\"Density\",fill=\"Species\")+\n  annotate(geom=\"label\",x=3650,y=0.0009,label=\"Adelie\",color=myCols[1]) +\n  annotate(geom=\"label\",x=3600,y=0.0005,label=\"Chinstrap\",color=myCols[2]) +\n  annotate(geom=\"label\",x=5100,y=0.0004,label=\"Gentoo\",color=\"gold3\")\n\n\n\n\n\n\n\n\n\n\nDealing with math in the labels: the bquote function\nWhat if you want to put non-standard characters into labels, like subscripts, superscripts, or Greek letters? For this example, we’ll draw on the scat dataset from the modeldata package:\n\nlibrary(modeldata)\n\nggplot(drop_na(scat,d13C,d15N),aes(x=d13C,y=d15N)) +\n  geom_point() \n\n\n\n\n\n\n\n\nHere, what we are showing is the relationship between two stable isotope concentrations: carbon-13 and nitrogen-15. These isotopes are used to evaluate and compare animal diets, and their values are typically expressed using superscripted numbers before the periodic symbol for the element (here C for carbon and N for nitrogen), and the Greek symbol delta indicating that it is differenced from a reference standard. For example:\n\\[\n\\delta^{13}C\n\\]\nand\n\\[\n\\delta^{15}N\n\\] If we want to modify the labels on the axes, we can change it using the bquote function:\n\nlibrary(modeldata)\n\nggplot(drop_na(scat,d13C,d15N),aes(x=d13C,y=d15N)) +\n  geom_point() +\n  labs(x=bquote(delta^13~C),y=bquote(delta^15~N))\n\n\n\n\n\n\n\n\nHere, rather than give a single text value, we provide bquote with an expression. For example, where it reads delta^13~C, this is saying combine the Greek letter delta with a superscripted 13 (^13) and then add a capital letter C at the end. The tilde (~) here is used when you need to transition between different parts of the phrase that don’t fit together naturally in sequence; for example, the superscripted 13 and the letter C.\n\n\n\n\n\n\nTry it yourself!\n\n\n\nUsing the Sacramento data, make a boxplot of square footage by property type, then try using bquote to create a label that shows the sqft variable as ft\\(^2\\).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Customizing Labels</span>"
    ]
  }
]